// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/serum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fserum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fserum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/basic.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fserum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fserum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fserum_2eproto;
namespace serum {
class Ask;
struct AskDefaultTypeInternal;
extern AskDefaultTypeInternal _Ask_default_instance_;
class Bid;
struct BidDefaultTypeInternal;
extern BidDefaultTypeInternal _Bid_default_instance_;
class CancelOrderRequest;
struct CancelOrderRequestDefaultTypeInternal;
extern CancelOrderRequestDefaultTypeInternal _CancelOrderRequest_default_instance_;
class CloseOpenOrderRequest;
struct CloseOpenOrderRequestDefaultTypeInternal;
extern CloseOpenOrderRequestDefaultTypeInternal _CloseOpenOrderRequest_default_instance_;
class ConsumeEventUpdate;
struct ConsumeEventUpdateDefaultTypeInternal;
extern ConsumeEventUpdateDefaultTypeInternal _ConsumeEventUpdate_default_instance_;
class ConsumeEventsRequest;
struct ConsumeEventsRequestDefaultTypeInternal;
extern ConsumeEventsRequestDefaultTypeInternal _ConsumeEventsRequest_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class InitOpenOrderRequest;
struct InitOpenOrderRequestDefaultTypeInternal;
extern InitOpenOrderRequestDefaultTypeInternal _InitOpenOrderRequest_default_instance_;
class InitializeTokenAccount;
struct InitializeTokenAccountDefaultTypeInternal;
extern InitializeTokenAccountDefaultTypeInternal _InitializeTokenAccount_default_instance_;
class ListMarketRequest;
struct ListMarketRequestDefaultTypeInternal;
extern ListMarketRequestDefaultTypeInternal _ListMarketRequest_default_instance_;
class ListMarketResponse;
struct ListMarketResponseDefaultTypeInternal;
extern ListMarketResponseDefaultTypeInternal _ListMarketResponse_default_instance_;
class MarketPubkeys;
struct MarketPubkeysDefaultTypeInternal;
extern MarketPubkeysDefaultTypeInternal _MarketPubkeys_default_instance_;
class MarketRequest;
struct MarketRequestDefaultTypeInternal;
extern MarketRequestDefaultTypeInternal _MarketRequest_default_instance_;
class MarketState;
struct MarketStateDefaultTypeInternal;
extern MarketStateDefaultTypeInternal _MarketState_default_instance_;
class MatchOrdersRequest;
struct MatchOrdersRequestDefaultTypeInternal;
extern MatchOrdersRequestDefaultTypeInternal _MatchOrdersRequest_default_instance_;
class MonitorQueueRequest;
struct MonitorQueueRequestDefaultTypeInternal;
extern MonitorQueueRequestDefaultTypeInternal _MonitorQueueRequest_default_instance_;
class NewOrderInstructionV3;
struct NewOrderInstructionV3DefaultTypeInternal;
extern NewOrderInstructionV3DefaultTypeInternal _NewOrderInstructionV3_default_instance_;
class Order;
struct OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class OrderStatus;
struct OrderStatusDefaultTypeInternal;
extern OrderStatusDefaultTypeInternal _OrderStatus_default_instance_;
class PrintEventQueue;
struct PrintEventQueueDefaultTypeInternal;
extern PrintEventQueueDefaultTypeInternal _PrintEventQueue_default_instance_;
class SettleFundsRequest;
struct SettleFundsRequestDefaultTypeInternal;
extern SettleFundsRequestDefaultTypeInternal _SettleFundsRequest_default_instance_;
class WholeShebang;
struct WholeShebangDefaultTypeInternal;
extern WholeShebangDefaultTypeInternal _WholeShebang_default_instance_;
}  // namespace serum
PROTOBUF_NAMESPACE_OPEN
template<> ::serum::Ask* Arena::CreateMaybeMessage<::serum::Ask>(Arena*);
template<> ::serum::Bid* Arena::CreateMaybeMessage<::serum::Bid>(Arena*);
template<> ::serum::CancelOrderRequest* Arena::CreateMaybeMessage<::serum::CancelOrderRequest>(Arena*);
template<> ::serum::CloseOpenOrderRequest* Arena::CreateMaybeMessage<::serum::CloseOpenOrderRequest>(Arena*);
template<> ::serum::ConsumeEventUpdate* Arena::CreateMaybeMessage<::serum::ConsumeEventUpdate>(Arena*);
template<> ::serum::ConsumeEventsRequest* Arena::CreateMaybeMessage<::serum::ConsumeEventsRequest>(Arena*);
template<> ::serum::Event* Arena::CreateMaybeMessage<::serum::Event>(Arena*);
template<> ::serum::InitOpenOrderRequest* Arena::CreateMaybeMessage<::serum::InitOpenOrderRequest>(Arena*);
template<> ::serum::InitializeTokenAccount* Arena::CreateMaybeMessage<::serum::InitializeTokenAccount>(Arena*);
template<> ::serum::ListMarketRequest* Arena::CreateMaybeMessage<::serum::ListMarketRequest>(Arena*);
template<> ::serum::ListMarketResponse* Arena::CreateMaybeMessage<::serum::ListMarketResponse>(Arena*);
template<> ::serum::MarketPubkeys* Arena::CreateMaybeMessage<::serum::MarketPubkeys>(Arena*);
template<> ::serum::MarketRequest* Arena::CreateMaybeMessage<::serum::MarketRequest>(Arena*);
template<> ::serum::MarketState* Arena::CreateMaybeMessage<::serum::MarketState>(Arena*);
template<> ::serum::MatchOrdersRequest* Arena::CreateMaybeMessage<::serum::MatchOrdersRequest>(Arena*);
template<> ::serum::MonitorQueueRequest* Arena::CreateMaybeMessage<::serum::MonitorQueueRequest>(Arena*);
template<> ::serum::NewOrderInstructionV3* Arena::CreateMaybeMessage<::serum::NewOrderInstructionV3>(Arena*);
template<> ::serum::Order* Arena::CreateMaybeMessage<::serum::Order>(Arena*);
template<> ::serum::OrderStatus* Arena::CreateMaybeMessage<::serum::OrderStatus>(Arena*);
template<> ::serum::PrintEventQueue* Arena::CreateMaybeMessage<::serum::PrintEventQueue>(Arena*);
template<> ::serum::SettleFundsRequest* Arena::CreateMaybeMessage<::serum::SettleFundsRequest>(Arena*);
template<> ::serum::WholeShebang* Arena::CreateMaybeMessage<::serum::WholeShebang>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace serum {

enum SelfTradeBehavior : int {
  DecrementTake = 0,
  CancelProvide = 1,
  AbortTransaction = 2,
  SelfTradeBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SelfTradeBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SelfTradeBehavior_IsValid(int value);
constexpr SelfTradeBehavior SelfTradeBehavior_MIN = DecrementTake;
constexpr SelfTradeBehavior SelfTradeBehavior_MAX = AbortTransaction;
constexpr int SelfTradeBehavior_ARRAYSIZE = SelfTradeBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelfTradeBehavior_descriptor();
template<typename T>
inline const std::string& SelfTradeBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelfTradeBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelfTradeBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelfTradeBehavior_descriptor(), enum_t_value);
}
inline bool SelfTradeBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SelfTradeBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelfTradeBehavior>(
    SelfTradeBehavior_descriptor(), name, value);
}
enum OrderType : int {
  Limit = 0,
  ImmediateOrCancel = 1,
  PostOnly = 2,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = Limit;
constexpr OrderType OrderType_MAX = PostOnly;
constexpr int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor();
template<typename T>
inline const std::string& OrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderType_descriptor(), enum_t_value);
}
inline bool OrderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
// ===================================================================

class MarketState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.MarketState) */ {
 public:
  inline MarketState() : MarketState(nullptr) {}
  ~MarketState() override;
  explicit constexpr MarketState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketState(const MarketState& from);
  MarketState(MarketState&& from) noexcept
    : MarketState() {
    *this = ::std::move(from);
  }

  inline MarketState& operator=(const MarketState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketState& operator=(MarketState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketState& default_instance() {
    return *internal_default_instance();
  }
  enum MarketCase {
    kId = 1,
    kState = 2,
    MARKET_NOT_SET = 0,
  };

  static inline const MarketState* internal_default_instance() {
    return reinterpret_cast<const MarketState*>(
               &_MarketState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MarketState& a, MarketState& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.MarketState";
  }
  protected:
  explicit MarketState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .basic.Pubkey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::basic::Pubkey& id() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_id();
  ::basic::Pubkey* mutable_id();
  void set_allocated_id(::basic::Pubkey* id);
  private:
  const ::basic::Pubkey& _internal_id() const;
  ::basic::Pubkey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::basic::Pubkey* id);
  ::basic::Pubkey* unsafe_arena_release_id();

  // .serum.MarketPubkeys state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::serum::MarketPubkeys& state() const;
  PROTOBUF_NODISCARD ::serum::MarketPubkeys* release_state();
  ::serum::MarketPubkeys* mutable_state();
  void set_allocated_state(::serum::MarketPubkeys* state);
  private:
  const ::serum::MarketPubkeys& _internal_state() const;
  ::serum::MarketPubkeys* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::serum::MarketPubkeys* state);
  ::serum::MarketPubkeys* unsafe_arena_release_state();

  void clear_market();
  MarketCase market_case() const;
  // @@protoc_insertion_point(class_scope:serum.MarketState)
 private:
  class _Internal;
  void set_has_id();
  void set_has_state();

  inline bool has_market() const;
  inline void clear_has_market();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MarketUnion {
    constexpr MarketUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::basic::Pubkey* id_;
    ::serum::MarketPubkeys* state_;
  } market_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class InitOpenOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.InitOpenOrderRequest) */ {
 public:
  inline InitOpenOrderRequest() : InitOpenOrderRequest(nullptr) {}
  ~InitOpenOrderRequest() override;
  explicit constexpr InitOpenOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitOpenOrderRequest(const InitOpenOrderRequest& from);
  InitOpenOrderRequest(InitOpenOrderRequest&& from) noexcept
    : InitOpenOrderRequest() {
    *this = ::std::move(from);
  }

  inline InitOpenOrderRequest& operator=(const InitOpenOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitOpenOrderRequest& operator=(InitOpenOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitOpenOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitOpenOrderRequest* internal_default_instance() {
    return reinterpret_cast<const InitOpenOrderRequest*>(
               &_InitOpenOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InitOpenOrderRequest& a, InitOpenOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitOpenOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitOpenOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitOpenOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitOpenOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitOpenOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitOpenOrderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitOpenOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.InitOpenOrderRequest";
  }
  protected:
  explicit InitOpenOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kMarketFieldNumber = 3,
    kOrdersFieldNumber = 4,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Keypair owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::basic::Keypair& owner() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_owner();
  ::basic::Keypair* mutable_owner();
  void set_allocated_owner(::basic::Keypair* owner);
  private:
  const ::basic::Keypair& _internal_owner() const;
  ::basic::Keypair* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::basic::Keypair* owner);
  ::basic::Keypair* unsafe_arena_release_owner();

  // .serum.MarketState market = 3;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey orders = 4;
  bool has_orders() const;
  private:
  bool _internal_has_orders() const;
  public:
  void clear_orders();
  const ::basic::Pubkey& orders() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_orders();
  ::basic::Pubkey* mutable_orders();
  void set_allocated_orders(::basic::Pubkey* orders);
  private:
  const ::basic::Pubkey& _internal_orders() const;
  ::basic::Pubkey* _internal_mutable_orders();
  public:
  void unsafe_arena_set_allocated_orders(
      ::basic::Pubkey* orders);
  ::basic::Pubkey* unsafe_arena_release_orders();

  // @@protoc_insertion_point(class_scope:serum.InitOpenOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Keypair* owner_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* orders_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class CloseOpenOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.CloseOpenOrderRequest) */ {
 public:
  inline CloseOpenOrderRequest() : CloseOpenOrderRequest(nullptr) {}
  ~CloseOpenOrderRequest() override;
  explicit constexpr CloseOpenOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseOpenOrderRequest(const CloseOpenOrderRequest& from);
  CloseOpenOrderRequest(CloseOpenOrderRequest&& from) noexcept
    : CloseOpenOrderRequest() {
    *this = ::std::move(from);
  }

  inline CloseOpenOrderRequest& operator=(const CloseOpenOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseOpenOrderRequest& operator=(CloseOpenOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseOpenOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseOpenOrderRequest* internal_default_instance() {
    return reinterpret_cast<const CloseOpenOrderRequest*>(
               &_CloseOpenOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CloseOpenOrderRequest& a, CloseOpenOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseOpenOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseOpenOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseOpenOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseOpenOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseOpenOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseOpenOrderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseOpenOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.CloseOpenOrderRequest";
  }
  protected:
  explicit CloseOpenOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kMarketFieldNumber = 3,
    kOrdersFieldNumber = 4,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Keypair owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::basic::Keypair& owner() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_owner();
  ::basic::Keypair* mutable_owner();
  void set_allocated_owner(::basic::Keypair* owner);
  private:
  const ::basic::Keypair& _internal_owner() const;
  ::basic::Keypair* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::basic::Keypair* owner);
  ::basic::Keypair* unsafe_arena_release_owner();

  // .serum.MarketState market = 3;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey orders = 4;
  bool has_orders() const;
  private:
  bool _internal_has_orders() const;
  public:
  void clear_orders();
  const ::basic::Pubkey& orders() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_orders();
  ::basic::Pubkey* mutable_orders();
  void set_allocated_orders(::basic::Pubkey* orders);
  private:
  const ::basic::Pubkey& _internal_orders() const;
  ::basic::Pubkey* _internal_mutable_orders();
  public:
  void unsafe_arena_set_allocated_orders(
      ::basic::Pubkey* orders);
  ::basic::Pubkey* unsafe_arena_release_orders();

  // @@protoc_insertion_point(class_scope:serum.CloseOpenOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Keypair* owner_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* orders_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class CancelOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.CancelOrderRequest) */ {
 public:
  inline CancelOrderRequest() : CancelOrderRequest(nullptr) {}
  ~CancelOrderRequest() override;
  explicit constexpr CancelOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOrderRequest(const CancelOrderRequest& from);
  CancelOrderRequest(CancelOrderRequest&& from) noexcept
    : CancelOrderRequest() {
    *this = ::std::move(from);
  }

  inline CancelOrderRequest& operator=(const CancelOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrderRequest& operator=(CancelOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOrderRequest* internal_default_instance() {
    return reinterpret_cast<const CancelOrderRequest*>(
               &_CancelOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CancelOrderRequest& a, CancelOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelOrderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.CancelOrderRequest";
  }
  protected:
  explicit CancelOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kMarketFieldNumber = 3,
    kOrdersFieldNumber = 4,
    kIdFieldNumber = 5,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Keypair owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::basic::Keypair& owner() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_owner();
  ::basic::Keypair* mutable_owner();
  void set_allocated_owner(::basic::Keypair* owner);
  private:
  const ::basic::Keypair& _internal_owner() const;
  ::basic::Keypair* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::basic::Keypair* owner);
  ::basic::Keypair* unsafe_arena_release_owner();

  // .serum.MarketState market = 3;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey orders = 4;
  bool has_orders() const;
  private:
  bool _internal_has_orders() const;
  public:
  void clear_orders();
  const ::basic::Pubkey& orders() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_orders();
  ::basic::Pubkey* mutable_orders();
  void set_allocated_orders(::basic::Pubkey* orders);
  private:
  const ::basic::Pubkey& _internal_orders() const;
  ::basic::Pubkey* _internal_mutable_orders();
  public:
  void unsafe_arena_set_allocated_orders(
      ::basic::Pubkey* orders);
  ::basic::Pubkey* unsafe_arena_release_orders();

  // uint64 id = 5;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:serum.CancelOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Keypair* owner_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* orders_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class ListMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.ListMarketResponse) */ {
 public:
  inline ListMarketResponse() : ListMarketResponse(nullptr) {}
  ~ListMarketResponse() override;
  explicit constexpr ListMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMarketResponse(const ListMarketResponse& from);
  ListMarketResponse(ListMarketResponse&& from) noexcept
    : ListMarketResponse() {
    *this = ::std::move(from);
  }

  inline ListMarketResponse& operator=(const ListMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMarketResponse& operator=(ListMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMarketResponse* internal_default_instance() {
    return reinterpret_cast<const ListMarketResponse*>(
               &_ListMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListMarketResponse& a, ListMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMarketResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListMarketResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.ListMarketResponse";
  }
  protected:
  explicit ListMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketPubkeysFieldNumber = 1,
    kTxFieldNumber = 2,
  };
  // .serum.MarketPubkeys market_pubkeys = 1;
  bool has_market_pubkeys() const;
  private:
  bool _internal_has_market_pubkeys() const;
  public:
  void clear_market_pubkeys();
  const ::serum::MarketPubkeys& market_pubkeys() const;
  PROTOBUF_NODISCARD ::serum::MarketPubkeys* release_market_pubkeys();
  ::serum::MarketPubkeys* mutable_market_pubkeys();
  void set_allocated_market_pubkeys(::serum::MarketPubkeys* market_pubkeys);
  private:
  const ::serum::MarketPubkeys& _internal_market_pubkeys() const;
  ::serum::MarketPubkeys* _internal_mutable_market_pubkeys();
  public:
  void unsafe_arena_set_allocated_market_pubkeys(
      ::serum::MarketPubkeys* market_pubkeys);
  ::serum::MarketPubkeys* unsafe_arena_release_market_pubkeys();

  // .basic.SignedTx tx = 2;
  bool has_tx() const;
  private:
  bool _internal_has_tx() const;
  public:
  void clear_tx();
  const ::basic::SignedTx& tx() const;
  PROTOBUF_NODISCARD ::basic::SignedTx* release_tx();
  ::basic::SignedTx* mutable_tx();
  void set_allocated_tx(::basic::SignedTx* tx);
  private:
  const ::basic::SignedTx& _internal_tx() const;
  ::basic::SignedTx* _internal_mutable_tx();
  public:
  void unsafe_arena_set_allocated_tx(
      ::basic::SignedTx* tx);
  ::basic::SignedTx* unsafe_arena_release_tx();

  // @@protoc_insertion_point(class_scope:serum.ListMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::serum::MarketPubkeys* market_pubkeys_;
  ::basic::SignedTx* tx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class Order final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.Order) */ {
 public:
  inline Order() : Order(nullptr) {}
  ~Order() override;
  explicit constexpr Order(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Order(const Order& from);
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  inline Order& operator=(Order&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Order& default_instance() {
    return *internal_default_instance();
  }
  enum OrderCase {
    kV3 = 1,
    ORDER_NOT_SET = 0,
  };

  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }
  inline void Swap(Order* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Order* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Order& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Order& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.Order";
  }
  protected:
  explicit Order(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 2,
    kPayerFieldNumber = 3,
    kWalletFieldNumber = 4,
    kMarketFieldNumber = 5,
    kOrdersFieldNumber = 6,
    kV3FieldNumber = 1,
  };
  // .basic.ProgramId dex_program_id = 2;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Keypair payer = 3;
  bool has_payer() const;
  private:
  bool _internal_has_payer() const;
  public:
  void clear_payer();
  const ::basic::Keypair& payer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_payer();
  ::basic::Keypair* mutable_payer();
  void set_allocated_payer(::basic::Keypair* payer);
  private:
  const ::basic::Keypair& _internal_payer() const;
  ::basic::Keypair* _internal_mutable_payer();
  public:
  void unsafe_arena_set_allocated_payer(
      ::basic::Keypair* payer);
  ::basic::Keypair* unsafe_arena_release_payer();

  // .basic.Pubkey wallet = 4;
  bool has_wallet() const;
  private:
  bool _internal_has_wallet() const;
  public:
  void clear_wallet();
  const ::basic::Pubkey& wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_wallet();
  ::basic::Pubkey* mutable_wallet();
  void set_allocated_wallet(::basic::Pubkey* wallet);
  private:
  const ::basic::Pubkey& _internal_wallet() const;
  ::basic::Pubkey* _internal_mutable_wallet();
  public:
  void unsafe_arena_set_allocated_wallet(
      ::basic::Pubkey* wallet);
  ::basic::Pubkey* unsafe_arena_release_wallet();

  // .serum.MarketState market = 5;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey orders = 6;
  bool has_orders() const;
  private:
  bool _internal_has_orders() const;
  public:
  void clear_orders();
  const ::basic::Pubkey& orders() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_orders();
  ::basic::Pubkey* mutable_orders();
  void set_allocated_orders(::basic::Pubkey* orders);
  private:
  const ::basic::Pubkey& _internal_orders() const;
  ::basic::Pubkey* _internal_mutable_orders();
  public:
  void unsafe_arena_set_allocated_orders(
      ::basic::Pubkey* orders);
  ::basic::Pubkey* unsafe_arena_release_orders();

  // .serum.NewOrderInstructionV3 v3 = 1;
  bool has_v3() const;
  private:
  bool _internal_has_v3() const;
  public:
  void clear_v3();
  const ::serum::NewOrderInstructionV3& v3() const;
  PROTOBUF_NODISCARD ::serum::NewOrderInstructionV3* release_v3();
  ::serum::NewOrderInstructionV3* mutable_v3();
  void set_allocated_v3(::serum::NewOrderInstructionV3* v3);
  private:
  const ::serum::NewOrderInstructionV3& _internal_v3() const;
  ::serum::NewOrderInstructionV3* _internal_mutable_v3();
  public:
  void unsafe_arena_set_allocated_v3(
      ::serum::NewOrderInstructionV3* v3);
  ::serum::NewOrderInstructionV3* unsafe_arena_release_v3();

  void clear_order();
  OrderCase order_case() const;
  // @@protoc_insertion_point(class_scope:serum.Order)
 private:
  class _Internal;
  void set_has_v3();

  inline bool has_order() const;
  inline void clear_has_order();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Keypair* payer_;
  ::basic::Pubkey* wallet_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* orders_;
  union OrderUnion {
    constexpr OrderUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::serum::NewOrderInstructionV3* v3_;
  } order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class OrderStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.OrderStatus) */ {
 public:
  inline OrderStatus() : OrderStatus(nullptr) {}
  ~OrderStatus() override;
  explicit constexpr OrderStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderStatus(const OrderStatus& from);
  OrderStatus(OrderStatus&& from) noexcept
    : OrderStatus() {
    *this = ::std::move(from);
  }

  inline OrderStatus& operator=(const OrderStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderStatus& operator=(OrderStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderStatus* internal_default_instance() {
    return reinterpret_cast<const OrderStatus*>(
               &_OrderStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OrderStatus& a, OrderStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrderStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.OrderStatus";
  }
  protected:
  explicit OrderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusWithSlotFieldNumber = 1,
  };
  // .basic.TxStatusWithSlot status_with_slot = 1;
  bool has_status_with_slot() const;
  private:
  bool _internal_has_status_with_slot() const;
  public:
  void clear_status_with_slot();
  const ::basic::TxStatusWithSlot& status_with_slot() const;
  PROTOBUF_NODISCARD ::basic::TxStatusWithSlot* release_status_with_slot();
  ::basic::TxStatusWithSlot* mutable_status_with_slot();
  void set_allocated_status_with_slot(::basic::TxStatusWithSlot* status_with_slot);
  private:
  const ::basic::TxStatusWithSlot& _internal_status_with_slot() const;
  ::basic::TxStatusWithSlot* _internal_mutable_status_with_slot();
  public:
  void unsafe_arena_set_allocated_status_with_slot(
      ::basic::TxStatusWithSlot* status_with_slot);
  ::basic::TxStatusWithSlot* unsafe_arena_release_status_with_slot();

  // @@protoc_insertion_point(class_scope:serum.OrderStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::TxStatusWithSlot* status_with_slot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class NewOrderInstructionV3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.NewOrderInstructionV3) */ {
 public:
  inline NewOrderInstructionV3() : NewOrderInstructionV3(nullptr) {}
  ~NewOrderInstructionV3() override;
  explicit constexpr NewOrderInstructionV3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewOrderInstructionV3(const NewOrderInstructionV3& from);
  NewOrderInstructionV3(NewOrderInstructionV3&& from) noexcept
    : NewOrderInstructionV3() {
    *this = ::std::move(from);
  }

  inline NewOrderInstructionV3& operator=(const NewOrderInstructionV3& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewOrderInstructionV3& operator=(NewOrderInstructionV3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewOrderInstructionV3& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewOrderInstructionV3* internal_default_instance() {
    return reinterpret_cast<const NewOrderInstructionV3*>(
               &_NewOrderInstructionV3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NewOrderInstructionV3& a, NewOrderInstructionV3& b) {
    a.Swap(&b);
  }
  inline void Swap(NewOrderInstructionV3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewOrderInstructionV3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewOrderInstructionV3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewOrderInstructionV3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewOrderInstructionV3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewOrderInstructionV3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrderInstructionV3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.NewOrderInstructionV3";
  }
  protected:
  explicit NewOrderInstructionV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitPriceFieldNumber = 2,
    kMaxCoinQtyFieldNumber = 3,
    kSideFieldNumber = 1,
    kSelfTradeBehaviorFieldNumber = 5,
    kMaxNativePcQtyIncludingFeesFieldNumber = 4,
    kClientOrderIdFieldNumber = 7,
    kOrderTypeFieldNumber = 6,
    kLimitFieldNumber = 8,
  };
  // uint64 limit_price = 2;
  void clear_limit_price();
  uint64_t limit_price() const;
  void set_limit_price(uint64_t value);
  private:
  uint64_t _internal_limit_price() const;
  void _internal_set_limit_price(uint64_t value);
  public:

  // uint64 max_coin_qty = 3;
  void clear_max_coin_qty();
  uint64_t max_coin_qty() const;
  void set_max_coin_qty(uint64_t value);
  private:
  uint64_t _internal_max_coin_qty() const;
  void _internal_set_max_coin_qty(uint64_t value);
  public:

  // bool side = 1;
  void clear_side();
  bool side() const;
  void set_side(bool value);
  private:
  bool _internal_side() const;
  void _internal_set_side(bool value);
  public:

  // .serum.SelfTradeBehavior self_trade_behavior = 5;
  void clear_self_trade_behavior();
  ::serum::SelfTradeBehavior self_trade_behavior() const;
  void set_self_trade_behavior(::serum::SelfTradeBehavior value);
  private:
  ::serum::SelfTradeBehavior _internal_self_trade_behavior() const;
  void _internal_set_self_trade_behavior(::serum::SelfTradeBehavior value);
  public:

  // uint64 max_native_pc_qty_including_fees = 4;
  void clear_max_native_pc_qty_including_fees();
  uint64_t max_native_pc_qty_including_fees() const;
  void set_max_native_pc_qty_including_fees(uint64_t value);
  private:
  uint64_t _internal_max_native_pc_qty_including_fees() const;
  void _internal_set_max_native_pc_qty_including_fees(uint64_t value);
  public:

  // uint64 client_order_id = 7;
  void clear_client_order_id();
  uint64_t client_order_id() const;
  void set_client_order_id(uint64_t value);
  private:
  uint64_t _internal_client_order_id() const;
  void _internal_set_client_order_id(uint64_t value);
  public:

  // .serum.OrderType order_type = 6;
  void clear_order_type();
  ::serum::OrderType order_type() const;
  void set_order_type(::serum::OrderType value);
  private:
  ::serum::OrderType _internal_order_type() const;
  void _internal_set_order_type(::serum::OrderType value);
  public:

  // uint32 limit = 8;
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:serum.NewOrderInstructionV3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t limit_price_;
  uint64_t max_coin_qty_;
  bool side_;
  int self_trade_behavior_;
  uint64_t max_native_pc_qty_including_fees_;
  uint64_t client_order_id_;
  int order_type_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kBid = 1,
    kAsk = 2,
    EVENT_NOT_SET = 0,
  };

  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBidFieldNumber = 1,
    kAskFieldNumber = 2,
  };
  // .serum.Bid bid = 1;
  bool has_bid() const;
  private:
  bool _internal_has_bid() const;
  public:
  void clear_bid();
  const ::serum::Bid& bid() const;
  PROTOBUF_NODISCARD ::serum::Bid* release_bid();
  ::serum::Bid* mutable_bid();
  void set_allocated_bid(::serum::Bid* bid);
  private:
  const ::serum::Bid& _internal_bid() const;
  ::serum::Bid* _internal_mutable_bid();
  public:
  void unsafe_arena_set_allocated_bid(
      ::serum::Bid* bid);
  ::serum::Bid* unsafe_arena_release_bid();

  // .serum.Ask ask = 2;
  bool has_ask() const;
  private:
  bool _internal_has_ask() const;
  public:
  void clear_ask();
  const ::serum::Ask& ask() const;
  PROTOBUF_NODISCARD ::serum::Ask* release_ask();
  ::serum::Ask* mutable_ask();
  void set_allocated_ask(::serum::Ask* ask);
  private:
  const ::serum::Ask& _internal_ask() const;
  ::serum::Ask* _internal_mutable_ask();
  public:
  void unsafe_arena_set_allocated_ask(
      ::serum::Ask* ask);
  ::serum::Ask* unsafe_arena_release_ask();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:serum.Event)
 private:
  class _Internal;
  void set_has_bid();
  void set_has_ask();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::serum::Bid* bid_;
    ::serum::Ask* ask_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class Bid final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:serum.Bid) */ {
 public:
  inline Bid() : Bid(nullptr) {}
  explicit constexpr Bid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bid(const Bid& from);
  Bid(Bid&& from) noexcept
    : Bid() {
    *this = ::std::move(from);
  }

  inline Bid& operator=(const Bid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bid& operator=(Bid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bid* internal_default_instance() {
    return reinterpret_cast<const Bid*>(
               &_Bid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Bid& a, Bid& b) {
    a.Swap(&b);
  }
  inline void Swap(Bid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bid& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bid& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.Bid";
  }
  protected:
  explicit Bid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:serum.Bid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class Ask final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:serum.Ask) */ {
 public:
  inline Ask() : Ask(nullptr) {}
  explicit constexpr Ask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ask(const Ask& from);
  Ask(Ask&& from) noexcept
    : Ask() {
    *this = ::std::move(from);
  }

  inline Ask& operator=(const Ask& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ask& operator=(Ask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ask& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ask* internal_default_instance() {
    return reinterpret_cast<const Ask*>(
               &_Ask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Ask& a, Ask& b) {
    a.Swap(&b);
  }
  inline void Swap(Ask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Ask& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Ask& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.Ask";
  }
  protected:
  explicit Ask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:serum.Ask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class ConsumeEventUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.ConsumeEventUpdate) */ {
 public:
  inline ConsumeEventUpdate() : ConsumeEventUpdate(nullptr) {}
  ~ConsumeEventUpdate() override;
  explicit constexpr ConsumeEventUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsumeEventUpdate(const ConsumeEventUpdate& from);
  ConsumeEventUpdate(ConsumeEventUpdate&& from) noexcept
    : ConsumeEventUpdate() {
    *this = ::std::move(from);
  }

  inline ConsumeEventUpdate& operator=(const ConsumeEventUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumeEventUpdate& operator=(ConsumeEventUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumeEventUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumeEventUpdate* internal_default_instance() {
    return reinterpret_cast<const ConsumeEventUpdate*>(
               &_ConsumeEventUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConsumeEventUpdate& a, ConsumeEventUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsumeEventUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumeEventUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumeEventUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsumeEventUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsumeEventUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsumeEventUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsumeEventUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.ConsumeEventUpdate";
  }
  protected:
  explicit ConsumeEventUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCrankCountFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // int64 crank_count = 1;
  void clear_crank_count();
  int64_t crank_count() const;
  void set_crank_count(int64_t value);
  private:
  int64_t _internal_crank_count() const;
  void _internal_set_crank_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:serum.ConsumeEventUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  int64_t crank_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class MarketPubkeys final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.MarketPubkeys) */ {
 public:
  inline MarketPubkeys() : MarketPubkeys(nullptr) {}
  ~MarketPubkeys() override;
  explicit constexpr MarketPubkeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketPubkeys(const MarketPubkeys& from);
  MarketPubkeys(MarketPubkeys&& from) noexcept
    : MarketPubkeys() {
    *this = ::std::move(from);
  }

  inline MarketPubkeys& operator=(const MarketPubkeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketPubkeys& operator=(MarketPubkeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketPubkeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketPubkeys* internal_default_instance() {
    return reinterpret_cast<const MarketPubkeys*>(
               &_MarketPubkeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MarketPubkeys& a, MarketPubkeys& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketPubkeys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketPubkeys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketPubkeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketPubkeys>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketPubkeys& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketPubkeys& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketPubkeys* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.MarketPubkeys";
  }
  protected:
  explicit MarketPubkeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
    kReqQFieldNumber = 2,
    kEventQFieldNumber = 3,
    kBidsFieldNumber = 4,
    kAsksFieldNumber = 5,
    kCoinVaultFieldNumber = 6,
    kPcVaultFieldNumber = 7,
    kVaultSignerKeyFieldNumber = 8,
  };
  // .basic.Pubkey market = 1;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::basic::Pubkey& market() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_market();
  ::basic::Pubkey* mutable_market();
  void set_allocated_market(::basic::Pubkey* market);
  private:
  const ::basic::Pubkey& _internal_market() const;
  ::basic::Pubkey* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::basic::Pubkey* market);
  ::basic::Pubkey* unsafe_arena_release_market();

  // .basic.Pubkey req_q = 2;
  bool has_req_q() const;
  private:
  bool _internal_has_req_q() const;
  public:
  void clear_req_q();
  const ::basic::Pubkey& req_q() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_req_q();
  ::basic::Pubkey* mutable_req_q();
  void set_allocated_req_q(::basic::Pubkey* req_q);
  private:
  const ::basic::Pubkey& _internal_req_q() const;
  ::basic::Pubkey* _internal_mutable_req_q();
  public:
  void unsafe_arena_set_allocated_req_q(
      ::basic::Pubkey* req_q);
  ::basic::Pubkey* unsafe_arena_release_req_q();

  // .basic.Pubkey event_q = 3;
  bool has_event_q() const;
  private:
  bool _internal_has_event_q() const;
  public:
  void clear_event_q();
  const ::basic::Pubkey& event_q() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_event_q();
  ::basic::Pubkey* mutable_event_q();
  void set_allocated_event_q(::basic::Pubkey* event_q);
  private:
  const ::basic::Pubkey& _internal_event_q() const;
  ::basic::Pubkey* _internal_mutable_event_q();
  public:
  void unsafe_arena_set_allocated_event_q(
      ::basic::Pubkey* event_q);
  ::basic::Pubkey* unsafe_arena_release_event_q();

  // .basic.Pubkey bids = 4;
  bool has_bids() const;
  private:
  bool _internal_has_bids() const;
  public:
  void clear_bids();
  const ::basic::Pubkey& bids() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_bids();
  ::basic::Pubkey* mutable_bids();
  void set_allocated_bids(::basic::Pubkey* bids);
  private:
  const ::basic::Pubkey& _internal_bids() const;
  ::basic::Pubkey* _internal_mutable_bids();
  public:
  void unsafe_arena_set_allocated_bids(
      ::basic::Pubkey* bids);
  ::basic::Pubkey* unsafe_arena_release_bids();

  // .basic.Pubkey asks = 5;
  bool has_asks() const;
  private:
  bool _internal_has_asks() const;
  public:
  void clear_asks();
  const ::basic::Pubkey& asks() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_asks();
  ::basic::Pubkey* mutable_asks();
  void set_allocated_asks(::basic::Pubkey* asks);
  private:
  const ::basic::Pubkey& _internal_asks() const;
  ::basic::Pubkey* _internal_mutable_asks();
  public:
  void unsafe_arena_set_allocated_asks(
      ::basic::Pubkey* asks);
  ::basic::Pubkey* unsafe_arena_release_asks();

  // .basic.Pubkey coin_vault = 6;
  bool has_coin_vault() const;
  private:
  bool _internal_has_coin_vault() const;
  public:
  void clear_coin_vault();
  const ::basic::Pubkey& coin_vault() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_coin_vault();
  ::basic::Pubkey* mutable_coin_vault();
  void set_allocated_coin_vault(::basic::Pubkey* coin_vault);
  private:
  const ::basic::Pubkey& _internal_coin_vault() const;
  ::basic::Pubkey* _internal_mutable_coin_vault();
  public:
  void unsafe_arena_set_allocated_coin_vault(
      ::basic::Pubkey* coin_vault);
  ::basic::Pubkey* unsafe_arena_release_coin_vault();

  // .basic.Pubkey pc_vault = 7;
  bool has_pc_vault() const;
  private:
  bool _internal_has_pc_vault() const;
  public:
  void clear_pc_vault();
  const ::basic::Pubkey& pc_vault() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_pc_vault();
  ::basic::Pubkey* mutable_pc_vault();
  void set_allocated_pc_vault(::basic::Pubkey* pc_vault);
  private:
  const ::basic::Pubkey& _internal_pc_vault() const;
  ::basic::Pubkey* _internal_mutable_pc_vault();
  public:
  void unsafe_arena_set_allocated_pc_vault(
      ::basic::Pubkey* pc_vault);
  ::basic::Pubkey* unsafe_arena_release_pc_vault();

  // .basic.Pubkey vault_signer_key = 8;
  bool has_vault_signer_key() const;
  private:
  bool _internal_has_vault_signer_key() const;
  public:
  void clear_vault_signer_key();
  const ::basic::Pubkey& vault_signer_key() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_vault_signer_key();
  ::basic::Pubkey* mutable_vault_signer_key();
  void set_allocated_vault_signer_key(::basic::Pubkey* vault_signer_key);
  private:
  const ::basic::Pubkey& _internal_vault_signer_key() const;
  ::basic::Pubkey* _internal_mutable_vault_signer_key();
  public:
  void unsafe_arena_set_allocated_vault_signer_key(
      ::basic::Pubkey* vault_signer_key);
  ::basic::Pubkey* unsafe_arena_release_vault_signer_key();

  // @@protoc_insertion_point(class_scope:serum.MarketPubkeys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::Pubkey* market_;
  ::basic::Pubkey* req_q_;
  ::basic::Pubkey* event_q_;
  ::basic::Pubkey* bids_;
  ::basic::Pubkey* asks_;
  ::basic::Pubkey* coin_vault_;
  ::basic::Pubkey* pc_vault_;
  ::basic::Pubkey* vault_signer_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class ConsumeEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.ConsumeEventsRequest) */ {
 public:
  inline ConsumeEventsRequest() : ConsumeEventsRequest(nullptr) {}
  ~ConsumeEventsRequest() override;
  explicit constexpr ConsumeEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsumeEventsRequest(const ConsumeEventsRequest& from);
  ConsumeEventsRequest(ConsumeEventsRequest&& from) noexcept
    : ConsumeEventsRequest() {
    *this = ::std::move(from);
  }

  inline ConsumeEventsRequest& operator=(const ConsumeEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumeEventsRequest& operator=(ConsumeEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumeEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumeEventsRequest* internal_default_instance() {
    return reinterpret_cast<const ConsumeEventsRequest*>(
               &_ConsumeEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ConsumeEventsRequest& a, ConsumeEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsumeEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumeEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumeEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsumeEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsumeEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsumeEventsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsumeEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.ConsumeEventsRequest";
  }
  protected:
  explicit ConsumeEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogDirectoryFieldNumber = 9,
    kDexProgramIdFieldNumber = 1,
    kPayerFieldNumber = 2,
    kMarketFieldNumber = 3,
    kCoinWalletFieldNumber = 4,
    kPcWalletFieldNumber = 5,
    kNumWorkersFieldNumber = 6,
    kEventsPerWorkerFieldNumber = 7,
    kNumAccountsFieldNumber = 8,
    kMaxQLengthFieldNumber = 10,
    kMaxWaitForEventsDelayFieldNumber = 11,
  };
  // string log_directory = 9;
  void clear_log_directory();
  const std::string& log_directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log_directory();
  PROTOBUF_NODISCARD std::string* release_log_directory();
  void set_allocated_log_directory(std::string* log_directory);
  private:
  const std::string& _internal_log_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_directory(const std::string& value);
  std::string* _internal_mutable_log_directory();
  public:

  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Keypair payer = 2;
  bool has_payer() const;
  private:
  bool _internal_has_payer() const;
  public:
  void clear_payer();
  const ::basic::Keypair& payer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_payer();
  ::basic::Keypair* mutable_payer();
  void set_allocated_payer(::basic::Keypair* payer);
  private:
  const ::basic::Keypair& _internal_payer() const;
  ::basic::Keypair* _internal_mutable_payer();
  public:
  void unsafe_arena_set_allocated_payer(
      ::basic::Keypair* payer);
  ::basic::Keypair* unsafe_arena_release_payer();

  // .serum.MarketState market = 3;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey coin_wallet = 4;
  bool has_coin_wallet() const;
  private:
  bool _internal_has_coin_wallet() const;
  public:
  void clear_coin_wallet();
  const ::basic::Pubkey& coin_wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_coin_wallet();
  ::basic::Pubkey* mutable_coin_wallet();
  void set_allocated_coin_wallet(::basic::Pubkey* coin_wallet);
  private:
  const ::basic::Pubkey& _internal_coin_wallet() const;
  ::basic::Pubkey* _internal_mutable_coin_wallet();
  public:
  void unsafe_arena_set_allocated_coin_wallet(
      ::basic::Pubkey* coin_wallet);
  ::basic::Pubkey* unsafe_arena_release_coin_wallet();

  // .basic.Pubkey pc_wallet = 5;
  bool has_pc_wallet() const;
  private:
  bool _internal_has_pc_wallet() const;
  public:
  void clear_pc_wallet();
  const ::basic::Pubkey& pc_wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_pc_wallet();
  ::basic::Pubkey* mutable_pc_wallet();
  void set_allocated_pc_wallet(::basic::Pubkey* pc_wallet);
  private:
  const ::basic::Pubkey& _internal_pc_wallet() const;
  ::basic::Pubkey* _internal_mutable_pc_wallet();
  public:
  void unsafe_arena_set_allocated_pc_wallet(
      ::basic::Pubkey* pc_wallet);
  ::basic::Pubkey* unsafe_arena_release_pc_wallet();

  // uint64 num_workers = 6;
  void clear_num_workers();
  uint64_t num_workers() const;
  void set_num_workers(uint64_t value);
  private:
  uint64_t _internal_num_workers() const;
  void _internal_set_num_workers(uint64_t value);
  public:

  // uint64 events_per_worker = 7;
  void clear_events_per_worker();
  uint64_t events_per_worker() const;
  void set_events_per_worker(uint64_t value);
  private:
  uint64_t _internal_events_per_worker() const;
  void _internal_set_events_per_worker(uint64_t value);
  public:

  // uint64 num_accounts = 8;
  void clear_num_accounts();
  uint64_t num_accounts() const;
  void set_num_accounts(uint64_t value);
  private:
  uint64_t _internal_num_accounts() const;
  void _internal_set_num_accounts(uint64_t value);
  public:

  // uint64 max_q_length = 10;
  void clear_max_q_length();
  uint64_t max_q_length() const;
  void set_max_q_length(uint64_t value);
  private:
  uint64_t _internal_max_q_length() const;
  void _internal_set_max_q_length(uint64_t value);
  public:

  // uint64 max_wait_for_events_delay = 11;
  void clear_max_wait_for_events_delay();
  uint64_t max_wait_for_events_delay() const;
  void set_max_wait_for_events_delay(uint64_t value);
  private:
  uint64_t _internal_max_wait_for_events_delay() const;
  void _internal_set_max_wait_for_events_delay(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:serum.ConsumeEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_directory_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Keypair* payer_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* coin_wallet_;
  ::basic::Pubkey* pc_wallet_;
  uint64_t num_workers_;
  uint64_t events_per_worker_;
  uint64_t num_accounts_;
  uint64_t max_q_length_;
  uint64_t max_wait_for_events_delay_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class MatchOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.MatchOrdersRequest) */ {
 public:
  inline MatchOrdersRequest() : MatchOrdersRequest(nullptr) {}
  ~MatchOrdersRequest() override;
  explicit constexpr MatchOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchOrdersRequest(const MatchOrdersRequest& from);
  MatchOrdersRequest(MatchOrdersRequest&& from) noexcept
    : MatchOrdersRequest() {
    *this = ::std::move(from);
  }

  inline MatchOrdersRequest& operator=(const MatchOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchOrdersRequest& operator=(MatchOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const MatchOrdersRequest*>(
               &_MatchOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MatchOrdersRequest& a, MatchOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchOrdersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchOrdersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.MatchOrdersRequest";
  }
  protected:
  explicit MatchOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kPayerFieldNumber = 2,
    kMarketFieldNumber = 3,
    kCoinWalletFieldNumber = 4,
    kPcWalletFieldNumber = 5,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Keypair payer = 2;
  bool has_payer() const;
  private:
  bool _internal_has_payer() const;
  public:
  void clear_payer();
  const ::basic::Keypair& payer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_payer();
  ::basic::Keypair* mutable_payer();
  void set_allocated_payer(::basic::Keypair* payer);
  private:
  const ::basic::Keypair& _internal_payer() const;
  ::basic::Keypair* _internal_mutable_payer();
  public:
  void unsafe_arena_set_allocated_payer(
      ::basic::Keypair* payer);
  ::basic::Keypair* unsafe_arena_release_payer();

  // .serum.MarketState market = 3;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey coin_wallet = 4;
  bool has_coin_wallet() const;
  private:
  bool _internal_has_coin_wallet() const;
  public:
  void clear_coin_wallet();
  const ::basic::Pubkey& coin_wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_coin_wallet();
  ::basic::Pubkey* mutable_coin_wallet();
  void set_allocated_coin_wallet(::basic::Pubkey* coin_wallet);
  private:
  const ::basic::Pubkey& _internal_coin_wallet() const;
  ::basic::Pubkey* _internal_mutable_coin_wallet();
  public:
  void unsafe_arena_set_allocated_coin_wallet(
      ::basic::Pubkey* coin_wallet);
  ::basic::Pubkey* unsafe_arena_release_coin_wallet();

  // .basic.Pubkey pc_wallet = 5;
  bool has_pc_wallet() const;
  private:
  bool _internal_has_pc_wallet() const;
  public:
  void clear_pc_wallet();
  const ::basic::Pubkey& pc_wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_pc_wallet();
  ::basic::Pubkey* mutable_pc_wallet();
  void set_allocated_pc_wallet(::basic::Pubkey* pc_wallet);
  private:
  const ::basic::Pubkey& _internal_pc_wallet() const;
  ::basic::Pubkey* _internal_mutable_pc_wallet();
  public:
  void unsafe_arena_set_allocated_pc_wallet(
      ::basic::Pubkey* pc_wallet);
  ::basic::Pubkey* unsafe_arena_release_pc_wallet();

  // @@protoc_insertion_point(class_scope:serum.MatchOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Keypair* payer_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* coin_wallet_;
  ::basic::Pubkey* pc_wallet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class MonitorQueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.MonitorQueueRequest) */ {
 public:
  inline MonitorQueueRequest() : MonitorQueueRequest(nullptr) {}
  ~MonitorQueueRequest() override;
  explicit constexpr MonitorQueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonitorQueueRequest(const MonitorQueueRequest& from);
  MonitorQueueRequest(MonitorQueueRequest&& from) noexcept
    : MonitorQueueRequest() {
    *this = ::std::move(from);
  }

  inline MonitorQueueRequest& operator=(const MonitorQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorQueueRequest& operator=(MonitorQueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitorQueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitorQueueRequest* internal_default_instance() {
    return reinterpret_cast<const MonitorQueueRequest*>(
               &_MonitorQueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MonitorQueueRequest& a, MonitorQueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorQueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitorQueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitorQueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonitorQueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonitorQueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MonitorQueueRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorQueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.MonitorQueueRequest";
  }
  protected:
  explicit MonitorQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kMarketFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .serum.MarketState market = 2;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // uint32 port = 3;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:serum.MonitorQueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::serum::MarketState* market_;
  uint32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class PrintEventQueue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.PrintEventQueue) */ {
 public:
  inline PrintEventQueue() : PrintEventQueue(nullptr) {}
  ~PrintEventQueue() override;
  explicit constexpr PrintEventQueue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintEventQueue(const PrintEventQueue& from);
  PrintEventQueue(PrintEventQueue&& from) noexcept
    : PrintEventQueue() {
    *this = ::std::move(from);
  }

  inline PrintEventQueue& operator=(const PrintEventQueue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintEventQueue& operator=(PrintEventQueue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrintEventQueue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintEventQueue* internal_default_instance() {
    return reinterpret_cast<const PrintEventQueue*>(
               &_PrintEventQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PrintEventQueue& a, PrintEventQueue& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintEventQueue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintEventQueue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintEventQueue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintEventQueue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrintEventQueue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrintEventQueue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrintEventQueue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.PrintEventQueue";
  }
  protected:
  explicit PrintEventQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kMarketFieldNumber = 2,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Pubkey market = 2;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::basic::Pubkey& market() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_market();
  ::basic::Pubkey* mutable_market();
  void set_allocated_market(::basic::Pubkey* market);
  private:
  const ::basic::Pubkey& _internal_market() const;
  ::basic::Pubkey* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::basic::Pubkey* market);
  ::basic::Pubkey* unsafe_arena_release_market();

  // @@protoc_insertion_point(class_scope:serum.PrintEventQueue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Pubkey* market_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class WholeShebang final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.WholeShebang) */ {
 public:
  inline WholeShebang() : WholeShebang(nullptr) {}
  ~WholeShebang() override;
  explicit constexpr WholeShebang(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WholeShebang(const WholeShebang& from);
  WholeShebang(WholeShebang&& from) noexcept
    : WholeShebang() {
    *this = ::std::move(from);
  }

  inline WholeShebang& operator=(const WholeShebang& from) {
    CopyFrom(from);
    return *this;
  }
  inline WholeShebang& operator=(WholeShebang&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WholeShebang& default_instance() {
    return *internal_default_instance();
  }
  static inline const WholeShebang* internal_default_instance() {
    return reinterpret_cast<const WholeShebang*>(
               &_WholeShebang_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WholeShebang& a, WholeShebang& b) {
    a.Swap(&b);
  }
  inline void Swap(WholeShebang* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WholeShebang* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WholeShebang* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WholeShebang>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WholeShebang& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WholeShebang& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WholeShebang* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.WholeShebang";
  }
  protected:
  explicit WholeShebang(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayerFieldNumber = 1,
    kDexProgramIdFieldNumber = 2,
  };
  // .basic.Keypair payer = 1;
  bool has_payer() const;
  private:
  bool _internal_has_payer() const;
  public:
  void clear_payer();
  const ::basic::Keypair& payer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_payer();
  ::basic::Keypair* mutable_payer();
  void set_allocated_payer(::basic::Keypair* payer);
  private:
  const ::basic::Keypair& _internal_payer() const;
  ::basic::Keypair* _internal_mutable_payer();
  public:
  void unsafe_arena_set_allocated_payer(
      ::basic::Keypair* payer);
  ::basic::Keypair* unsafe_arena_release_payer();

  // .basic.ProgramId dex_program_id = 2;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // @@protoc_insertion_point(class_scope:serum.WholeShebang)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::Keypair* payer_;
  ::basic::ProgramId* dex_program_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class SettleFundsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.SettleFundsRequest) */ {
 public:
  inline SettleFundsRequest() : SettleFundsRequest(nullptr) {}
  ~SettleFundsRequest() override;
  explicit constexpr SettleFundsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SettleFundsRequest(const SettleFundsRequest& from);
  SettleFundsRequest(SettleFundsRequest&& from) noexcept
    : SettleFundsRequest() {
    *this = ::std::move(from);
  }

  inline SettleFundsRequest& operator=(const SettleFundsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettleFundsRequest& operator=(SettleFundsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettleFundsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettleFundsRequest* internal_default_instance() {
    return reinterpret_cast<const SettleFundsRequest*>(
               &_SettleFundsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SettleFundsRequest& a, SettleFundsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SettleFundsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettleFundsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettleFundsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettleFundsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SettleFundsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SettleFundsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettleFundsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.SettleFundsRequest";
  }
  protected:
  explicit SettleFundsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayerFieldNumber = 1,
    kDexProgramIdFieldNumber = 2,
    kMarketFieldNumber = 3,
    kOrdersFieldNumber = 4,
    kCoinWalletFieldNumber = 5,
    kPcWalletFieldNumber = 6,
    kSignerFieldNumber = 7,
  };
  // .basic.Keypair payer = 1;
  bool has_payer() const;
  private:
  bool _internal_has_payer() const;
  public:
  void clear_payer();
  const ::basic::Keypair& payer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_payer();
  ::basic::Keypair* mutable_payer();
  void set_allocated_payer(::basic::Keypair* payer);
  private:
  const ::basic::Keypair& _internal_payer() const;
  ::basic::Keypair* _internal_mutable_payer();
  public:
  void unsafe_arena_set_allocated_payer(
      ::basic::Keypair* payer);
  ::basic::Keypair* unsafe_arena_release_payer();

  // .basic.ProgramId dex_program_id = 2;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .serum.MarketState market = 3;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::serum::MarketState& market() const;
  PROTOBUF_NODISCARD ::serum::MarketState* release_market();
  ::serum::MarketState* mutable_market();
  void set_allocated_market(::serum::MarketState* market);
  private:
  const ::serum::MarketState& _internal_market() const;
  ::serum::MarketState* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::serum::MarketState* market);
  ::serum::MarketState* unsafe_arena_release_market();

  // .basic.Pubkey orders = 4;
  bool has_orders() const;
  private:
  bool _internal_has_orders() const;
  public:
  void clear_orders();
  const ::basic::Pubkey& orders() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_orders();
  ::basic::Pubkey* mutable_orders();
  void set_allocated_orders(::basic::Pubkey* orders);
  private:
  const ::basic::Pubkey& _internal_orders() const;
  ::basic::Pubkey* _internal_mutable_orders();
  public:
  void unsafe_arena_set_allocated_orders(
      ::basic::Pubkey* orders);
  ::basic::Pubkey* unsafe_arena_release_orders();

  // .basic.Pubkey coin_wallet = 5;
  bool has_coin_wallet() const;
  private:
  bool _internal_has_coin_wallet() const;
  public:
  void clear_coin_wallet();
  const ::basic::Pubkey& coin_wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_coin_wallet();
  ::basic::Pubkey* mutable_coin_wallet();
  void set_allocated_coin_wallet(::basic::Pubkey* coin_wallet);
  private:
  const ::basic::Pubkey& _internal_coin_wallet() const;
  ::basic::Pubkey* _internal_mutable_coin_wallet();
  public:
  void unsafe_arena_set_allocated_coin_wallet(
      ::basic::Pubkey* coin_wallet);
  ::basic::Pubkey* unsafe_arena_release_coin_wallet();

  // .basic.Pubkey pc_wallet = 6;
  bool has_pc_wallet() const;
  private:
  bool _internal_has_pc_wallet() const;
  public:
  void clear_pc_wallet();
  const ::basic::Pubkey& pc_wallet() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_pc_wallet();
  ::basic::Pubkey* mutable_pc_wallet();
  void set_allocated_pc_wallet(::basic::Pubkey* pc_wallet);
  private:
  const ::basic::Pubkey& _internal_pc_wallet() const;
  ::basic::Pubkey* _internal_mutable_pc_wallet();
  public:
  void unsafe_arena_set_allocated_pc_wallet(
      ::basic::Pubkey* pc_wallet);
  ::basic::Pubkey* unsafe_arena_release_pc_wallet();

  // .basic.Keypair signer = 7;
  bool has_signer() const;
  private:
  bool _internal_has_signer() const;
  public:
  void clear_signer();
  const ::basic::Keypair& signer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_signer();
  ::basic::Keypair* mutable_signer();
  void set_allocated_signer(::basic::Keypair* signer);
  private:
  const ::basic::Keypair& _internal_signer() const;
  ::basic::Keypair* _internal_mutable_signer();
  public:
  void unsafe_arena_set_allocated_signer(
      ::basic::Keypair* signer);
  ::basic::Keypair* unsafe_arena_release_signer();

  // @@protoc_insertion_point(class_scope:serum.SettleFundsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::Keypair* payer_;
  ::basic::ProgramId* dex_program_id_;
  ::serum::MarketState* market_;
  ::basic::Pubkey* orders_;
  ::basic::Pubkey* coin_wallet_;
  ::basic::Pubkey* pc_wallet_;
  ::basic::Keypair* signer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class ListMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.ListMarketRequest) */ {
 public:
  inline ListMarketRequest() : ListMarketRequest(nullptr) {}
  ~ListMarketRequest() override;
  explicit constexpr ListMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMarketRequest(const ListMarketRequest& from);
  ListMarketRequest(ListMarketRequest&& from) noexcept
    : ListMarketRequest() {
    *this = ::std::move(from);
  }

  inline ListMarketRequest& operator=(const ListMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMarketRequest& operator=(ListMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMarketRequest* internal_default_instance() {
    return reinterpret_cast<const ListMarketRequest*>(
               &_ListMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListMarketRequest& a, ListMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMarketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListMarketRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.ListMarketRequest";
  }
  protected:
  explicit ListMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayerFieldNumber = 1,
    kDexProgramIdFieldNumber = 2,
    kCoinMintFieldNumber = 3,
    kPcMintFieldNumber = 4,
    kCoinLotSizeFieldNumber = 5,
    kPcLotSizeFieldNumber = 6,
  };
  // .basic.Keypair payer = 1;
  bool has_payer() const;
  private:
  bool _internal_has_payer() const;
  public:
  void clear_payer();
  const ::basic::Keypair& payer() const;
  PROTOBUF_NODISCARD ::basic::Keypair* release_payer();
  ::basic::Keypair* mutable_payer();
  void set_allocated_payer(::basic::Keypair* payer);
  private:
  const ::basic::Keypair& _internal_payer() const;
  ::basic::Keypair* _internal_mutable_payer();
  public:
  void unsafe_arena_set_allocated_payer(
      ::basic::Keypair* payer);
  ::basic::Keypair* unsafe_arena_release_payer();

  // .basic.ProgramId dex_program_id = 2;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Pubkey coin_mint = 3;
  bool has_coin_mint() const;
  private:
  bool _internal_has_coin_mint() const;
  public:
  void clear_coin_mint();
  const ::basic::Pubkey& coin_mint() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_coin_mint();
  ::basic::Pubkey* mutable_coin_mint();
  void set_allocated_coin_mint(::basic::Pubkey* coin_mint);
  private:
  const ::basic::Pubkey& _internal_coin_mint() const;
  ::basic::Pubkey* _internal_mutable_coin_mint();
  public:
  void unsafe_arena_set_allocated_coin_mint(
      ::basic::Pubkey* coin_mint);
  ::basic::Pubkey* unsafe_arena_release_coin_mint();

  // .basic.Pubkey pc_mint = 4;
  bool has_pc_mint() const;
  private:
  bool _internal_has_pc_mint() const;
  public:
  void clear_pc_mint();
  const ::basic::Pubkey& pc_mint() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_pc_mint();
  ::basic::Pubkey* mutable_pc_mint();
  void set_allocated_pc_mint(::basic::Pubkey* pc_mint);
  private:
  const ::basic::Pubkey& _internal_pc_mint() const;
  ::basic::Pubkey* _internal_mutable_pc_mint();
  public:
  void unsafe_arena_set_allocated_pc_mint(
      ::basic::Pubkey* pc_mint);
  ::basic::Pubkey* unsafe_arena_release_pc_mint();

  // uint64 coin_lot_size = 5;
  void clear_coin_lot_size();
  uint64_t coin_lot_size() const;
  void set_coin_lot_size(uint64_t value);
  private:
  uint64_t _internal_coin_lot_size() const;
  void _internal_set_coin_lot_size(uint64_t value);
  public:

  // uint64 pc_lot_size = 6;
  void clear_pc_lot_size();
  uint64_t pc_lot_size() const;
  void set_pc_lot_size(uint64_t value);
  private:
  uint64_t _internal_pc_lot_size() const;
  void _internal_set_pc_lot_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:serum.ListMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::Keypair* payer_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Pubkey* coin_mint_;
  ::basic::Pubkey* pc_mint_;
  uint64_t coin_lot_size_;
  uint64_t pc_lot_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class InitializeTokenAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.InitializeTokenAccount) */ {
 public:
  inline InitializeTokenAccount() : InitializeTokenAccount(nullptr) {}
  ~InitializeTokenAccount() override;
  explicit constexpr InitializeTokenAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeTokenAccount(const InitializeTokenAccount& from);
  InitializeTokenAccount(InitializeTokenAccount&& from) noexcept
    : InitializeTokenAccount() {
    *this = ::std::move(from);
  }

  inline InitializeTokenAccount& operator=(const InitializeTokenAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeTokenAccount& operator=(InitializeTokenAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeTokenAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeTokenAccount* internal_default_instance() {
    return reinterpret_cast<const InitializeTokenAccount*>(
               &_InitializeTokenAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(InitializeTokenAccount& a, InitializeTokenAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeTokenAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeTokenAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeTokenAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeTokenAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeTokenAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitializeTokenAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeTokenAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.InitializeTokenAccount";
  }
  protected:
  explicit InitializeTokenAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMintFieldNumber = 1,
    kOwnerAccountFieldNumber = 2,
  };
  // .basic.Pubkey mint = 1;
  bool has_mint() const;
  private:
  bool _internal_has_mint() const;
  public:
  void clear_mint();
  const ::basic::Pubkey& mint() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_mint();
  ::basic::Pubkey* mutable_mint();
  void set_allocated_mint(::basic::Pubkey* mint);
  private:
  const ::basic::Pubkey& _internal_mint() const;
  ::basic::Pubkey* _internal_mutable_mint();
  public:
  void unsafe_arena_set_allocated_mint(
      ::basic::Pubkey* mint);
  ::basic::Pubkey* unsafe_arena_release_mint();

  // .basic.Pubkey owner_account = 2;
  bool has_owner_account() const;
  private:
  bool _internal_has_owner_account() const;
  public:
  void clear_owner_account();
  const ::basic::Pubkey& owner_account() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_owner_account();
  ::basic::Pubkey* mutable_owner_account();
  void set_allocated_owner_account(::basic::Pubkey* owner_account);
  private:
  const ::basic::Pubkey& _internal_owner_account() const;
  ::basic::Pubkey* _internal_mutable_owner_account();
  public:
  void unsafe_arena_set_allocated_owner_account(
      ::basic::Pubkey* owner_account);
  ::basic::Pubkey* unsafe_arena_release_owner_account();

  // @@protoc_insertion_point(class_scope:serum.InitializeTokenAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::Pubkey* mint_;
  ::basic::Pubkey* owner_account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// -------------------------------------------------------------------

class MarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serum.MarketRequest) */ {
 public:
  inline MarketRequest() : MarketRequest(nullptr) {}
  ~MarketRequest() override;
  explicit constexpr MarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketRequest(const MarketRequest& from);
  MarketRequest(MarketRequest&& from) noexcept
    : MarketRequest() {
    *this = ::std::move(from);
  }

  inline MarketRequest& operator=(const MarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketRequest& operator=(MarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketRequest* internal_default_instance() {
    return reinterpret_cast<const MarketRequest*>(
               &_MarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MarketRequest& a, MarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serum.MarketRequest";
  }
  protected:
  explicit MarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDexProgramIdFieldNumber = 1,
    kMarketFieldNumber = 2,
  };
  // .basic.ProgramId dex_program_id = 1;
  bool has_dex_program_id() const;
  private:
  bool _internal_has_dex_program_id() const;
  public:
  void clear_dex_program_id();
  const ::basic::ProgramId& dex_program_id() const;
  PROTOBUF_NODISCARD ::basic::ProgramId* release_dex_program_id();
  ::basic::ProgramId* mutable_dex_program_id();
  void set_allocated_dex_program_id(::basic::ProgramId* dex_program_id);
  private:
  const ::basic::ProgramId& _internal_dex_program_id() const;
  ::basic::ProgramId* _internal_mutable_dex_program_id();
  public:
  void unsafe_arena_set_allocated_dex_program_id(
      ::basic::ProgramId* dex_program_id);
  ::basic::ProgramId* unsafe_arena_release_dex_program_id();

  // .basic.Pubkey market = 2;
  bool has_market() const;
  private:
  bool _internal_has_market() const;
  public:
  void clear_market();
  const ::basic::Pubkey& market() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_market();
  ::basic::Pubkey* mutable_market();
  void set_allocated_market(::basic::Pubkey* market);
  private:
  const ::basic::Pubkey& _internal_market() const;
  ::basic::Pubkey* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::basic::Pubkey* market);
  ::basic::Pubkey* unsafe_arena_release_market();

  // @@protoc_insertion_point(class_scope:serum.MarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::ProgramId* dex_program_id_;
  ::basic::Pubkey* market_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserum_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MarketState

// .basic.Pubkey id = 1;
inline bool MarketState::_internal_has_id() const {
  return market_case() == kId;
}
inline bool MarketState::has_id() const {
  return _internal_has_id();
}
inline void MarketState::set_has_id() {
  _oneof_case_[0] = kId;
}
inline ::basic::Pubkey* MarketState::release_id() {
  // @@protoc_insertion_point(field_release:serum.MarketState.id)
  if (_internal_has_id()) {
    clear_has_market();
      ::basic::Pubkey* temp = market_.id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    market_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::basic::Pubkey& MarketState::_internal_id() const {
  return _internal_has_id()
      ? *market_.id_
      : reinterpret_cast< ::basic::Pubkey&>(::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketState::id() const {
  // @@protoc_insertion_point(field_get:serum.MarketState.id)
  return _internal_id();
}
inline ::basic::Pubkey* MarketState::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serum.MarketState.id)
  if (_internal_has_id()) {
    clear_has_market();
    ::basic::Pubkey* temp = market_.id_;
    market_.id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MarketState::unsafe_arena_set_allocated_id(::basic::Pubkey* id) {
  clear_market();
  if (id) {
    set_has_id();
    market_.id_ = id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketState.id)
}
inline ::basic::Pubkey* MarketState::_internal_mutable_id() {
  if (!_internal_has_id()) {
    clear_market();
    set_has_id();
    market_.id_ = CreateMaybeMessage< ::basic::Pubkey >(GetArenaForAllocation());
  }
  return market_.id_;
}
inline ::basic::Pubkey* MarketState::mutable_id() {
  ::basic::Pubkey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:serum.MarketState.id)
  return _msg;
}

// .serum.MarketPubkeys state = 2;
inline bool MarketState::_internal_has_state() const {
  return market_case() == kState;
}
inline bool MarketState::has_state() const {
  return _internal_has_state();
}
inline void MarketState::set_has_state() {
  _oneof_case_[0] = kState;
}
inline void MarketState::clear_state() {
  if (_internal_has_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete market_.state_;
    }
    clear_has_market();
  }
}
inline ::serum::MarketPubkeys* MarketState::release_state() {
  // @@protoc_insertion_point(field_release:serum.MarketState.state)
  if (_internal_has_state()) {
    clear_has_market();
      ::serum::MarketPubkeys* temp = market_.state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    market_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::serum::MarketPubkeys& MarketState::_internal_state() const {
  return _internal_has_state()
      ? *market_.state_
      : reinterpret_cast< ::serum::MarketPubkeys&>(::serum::_MarketPubkeys_default_instance_);
}
inline const ::serum::MarketPubkeys& MarketState::state() const {
  // @@protoc_insertion_point(field_get:serum.MarketState.state)
  return _internal_state();
}
inline ::serum::MarketPubkeys* MarketState::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serum.MarketState.state)
  if (_internal_has_state()) {
    clear_has_market();
    ::serum::MarketPubkeys* temp = market_.state_;
    market_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MarketState::unsafe_arena_set_allocated_state(::serum::MarketPubkeys* state) {
  clear_market();
  if (state) {
    set_has_state();
    market_.state_ = state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketState.state)
}
inline ::serum::MarketPubkeys* MarketState::_internal_mutable_state() {
  if (!_internal_has_state()) {
    clear_market();
    set_has_state();
    market_.state_ = CreateMaybeMessage< ::serum::MarketPubkeys >(GetArenaForAllocation());
  }
  return market_.state_;
}
inline ::serum::MarketPubkeys* MarketState::mutable_state() {
  ::serum::MarketPubkeys* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:serum.MarketState.state)
  return _msg;
}

inline bool MarketState::has_market() const {
  return market_case() != MARKET_NOT_SET;
}
inline void MarketState::clear_has_market() {
  _oneof_case_[0] = MARKET_NOT_SET;
}
inline MarketState::MarketCase MarketState::market_case() const {
  return MarketState::MarketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InitOpenOrderRequest

// .basic.ProgramId dex_program_id = 1;
inline bool InitOpenOrderRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool InitOpenOrderRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& InitOpenOrderRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& InitOpenOrderRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.InitOpenOrderRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void InitOpenOrderRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.InitOpenOrderRequest.dex_program_id)
}
inline ::basic::ProgramId* InitOpenOrderRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* InitOpenOrderRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.InitOpenOrderRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* InitOpenOrderRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* InitOpenOrderRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.InitOpenOrderRequest.dex_program_id)
  return _msg;
}
inline void InitOpenOrderRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.InitOpenOrderRequest.dex_program_id)
}

// .basic.Keypair owner = 2;
inline bool InitOpenOrderRequest::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool InitOpenOrderRequest::has_owner() const {
  return _internal_has_owner();
}
inline const ::basic::Keypair& InitOpenOrderRequest::_internal_owner() const {
  const ::basic::Keypair* p = owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& InitOpenOrderRequest::owner() const {
  // @@protoc_insertion_point(field_get:serum.InitOpenOrderRequest.owner)
  return _internal_owner();
}
inline void InitOpenOrderRequest::unsafe_arena_set_allocated_owner(
    ::basic::Keypair* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.InitOpenOrderRequest.owner)
}
inline ::basic::Keypair* InitOpenOrderRequest::release_owner() {
  
  ::basic::Keypair* temp = owner_;
  owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* InitOpenOrderRequest::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:serum.InitOpenOrderRequest.owner)
  
  ::basic::Keypair* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::basic::Keypair* InitOpenOrderRequest::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    owner_ = p;
  }
  return owner_;
}
inline ::basic::Keypair* InitOpenOrderRequest::mutable_owner() {
  ::basic::Keypair* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:serum.InitOpenOrderRequest.owner)
  return _msg;
}
inline void InitOpenOrderRequest::set_allocated_owner(::basic::Keypair* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:serum.InitOpenOrderRequest.owner)
}

// .serum.MarketState market = 3;
inline bool InitOpenOrderRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool InitOpenOrderRequest::has_market() const {
  return _internal_has_market();
}
inline void InitOpenOrderRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& InitOpenOrderRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& InitOpenOrderRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.InitOpenOrderRequest.market)
  return _internal_market();
}
inline void InitOpenOrderRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.InitOpenOrderRequest.market)
}
inline ::serum::MarketState* InitOpenOrderRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* InitOpenOrderRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.InitOpenOrderRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* InitOpenOrderRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* InitOpenOrderRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.InitOpenOrderRequest.market)
  return _msg;
}
inline void InitOpenOrderRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.InitOpenOrderRequest.market)
}

// .basic.Pubkey orders = 4;
inline bool InitOpenOrderRequest::_internal_has_orders() const {
  return this != internal_default_instance() && orders_ != nullptr;
}
inline bool InitOpenOrderRequest::has_orders() const {
  return _internal_has_orders();
}
inline const ::basic::Pubkey& InitOpenOrderRequest::_internal_orders() const {
  const ::basic::Pubkey* p = orders_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& InitOpenOrderRequest::orders() const {
  // @@protoc_insertion_point(field_get:serum.InitOpenOrderRequest.orders)
  return _internal_orders();
}
inline void InitOpenOrderRequest::unsafe_arena_set_allocated_orders(
    ::basic::Pubkey* orders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  orders_ = orders;
  if (orders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.InitOpenOrderRequest.orders)
}
inline ::basic::Pubkey* InitOpenOrderRequest::release_orders() {
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* InitOpenOrderRequest::unsafe_arena_release_orders() {
  // @@protoc_insertion_point(field_release:serum.InitOpenOrderRequest.orders)
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* InitOpenOrderRequest::_internal_mutable_orders() {
  
  if (orders_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    orders_ = p;
  }
  return orders_;
}
inline ::basic::Pubkey* InitOpenOrderRequest::mutable_orders() {
  ::basic::Pubkey* _msg = _internal_mutable_orders();
  // @@protoc_insertion_point(field_mutable:serum.InitOpenOrderRequest.orders)
  return _msg;
}
inline void InitOpenOrderRequest::set_allocated_orders(::basic::Pubkey* orders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  if (orders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders));
    if (message_arena != submessage_arena) {
      orders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orders, submessage_arena);
    }
    
  } else {
    
  }
  orders_ = orders;
  // @@protoc_insertion_point(field_set_allocated:serum.InitOpenOrderRequest.orders)
}

// -------------------------------------------------------------------

// CloseOpenOrderRequest

// .basic.ProgramId dex_program_id = 1;
inline bool CloseOpenOrderRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool CloseOpenOrderRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& CloseOpenOrderRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& CloseOpenOrderRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.CloseOpenOrderRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void CloseOpenOrderRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CloseOpenOrderRequest.dex_program_id)
}
inline ::basic::ProgramId* CloseOpenOrderRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* CloseOpenOrderRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.CloseOpenOrderRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* CloseOpenOrderRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* CloseOpenOrderRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.CloseOpenOrderRequest.dex_program_id)
  return _msg;
}
inline void CloseOpenOrderRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.CloseOpenOrderRequest.dex_program_id)
}

// .basic.Keypair owner = 2;
inline bool CloseOpenOrderRequest::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool CloseOpenOrderRequest::has_owner() const {
  return _internal_has_owner();
}
inline const ::basic::Keypair& CloseOpenOrderRequest::_internal_owner() const {
  const ::basic::Keypair* p = owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& CloseOpenOrderRequest::owner() const {
  // @@protoc_insertion_point(field_get:serum.CloseOpenOrderRequest.owner)
  return _internal_owner();
}
inline void CloseOpenOrderRequest::unsafe_arena_set_allocated_owner(
    ::basic::Keypair* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CloseOpenOrderRequest.owner)
}
inline ::basic::Keypair* CloseOpenOrderRequest::release_owner() {
  
  ::basic::Keypair* temp = owner_;
  owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* CloseOpenOrderRequest::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:serum.CloseOpenOrderRequest.owner)
  
  ::basic::Keypair* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::basic::Keypair* CloseOpenOrderRequest::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    owner_ = p;
  }
  return owner_;
}
inline ::basic::Keypair* CloseOpenOrderRequest::mutable_owner() {
  ::basic::Keypair* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:serum.CloseOpenOrderRequest.owner)
  return _msg;
}
inline void CloseOpenOrderRequest::set_allocated_owner(::basic::Keypair* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:serum.CloseOpenOrderRequest.owner)
}

// .serum.MarketState market = 3;
inline bool CloseOpenOrderRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool CloseOpenOrderRequest::has_market() const {
  return _internal_has_market();
}
inline void CloseOpenOrderRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& CloseOpenOrderRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& CloseOpenOrderRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.CloseOpenOrderRequest.market)
  return _internal_market();
}
inline void CloseOpenOrderRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CloseOpenOrderRequest.market)
}
inline ::serum::MarketState* CloseOpenOrderRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* CloseOpenOrderRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.CloseOpenOrderRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* CloseOpenOrderRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* CloseOpenOrderRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.CloseOpenOrderRequest.market)
  return _msg;
}
inline void CloseOpenOrderRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.CloseOpenOrderRequest.market)
}

// .basic.Pubkey orders = 4;
inline bool CloseOpenOrderRequest::_internal_has_orders() const {
  return this != internal_default_instance() && orders_ != nullptr;
}
inline bool CloseOpenOrderRequest::has_orders() const {
  return _internal_has_orders();
}
inline const ::basic::Pubkey& CloseOpenOrderRequest::_internal_orders() const {
  const ::basic::Pubkey* p = orders_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& CloseOpenOrderRequest::orders() const {
  // @@protoc_insertion_point(field_get:serum.CloseOpenOrderRequest.orders)
  return _internal_orders();
}
inline void CloseOpenOrderRequest::unsafe_arena_set_allocated_orders(
    ::basic::Pubkey* orders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  orders_ = orders;
  if (orders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CloseOpenOrderRequest.orders)
}
inline ::basic::Pubkey* CloseOpenOrderRequest::release_orders() {
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* CloseOpenOrderRequest::unsafe_arena_release_orders() {
  // @@protoc_insertion_point(field_release:serum.CloseOpenOrderRequest.orders)
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* CloseOpenOrderRequest::_internal_mutable_orders() {
  
  if (orders_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    orders_ = p;
  }
  return orders_;
}
inline ::basic::Pubkey* CloseOpenOrderRequest::mutable_orders() {
  ::basic::Pubkey* _msg = _internal_mutable_orders();
  // @@protoc_insertion_point(field_mutable:serum.CloseOpenOrderRequest.orders)
  return _msg;
}
inline void CloseOpenOrderRequest::set_allocated_orders(::basic::Pubkey* orders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  if (orders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders));
    if (message_arena != submessage_arena) {
      orders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orders, submessage_arena);
    }
    
  } else {
    
  }
  orders_ = orders;
  // @@protoc_insertion_point(field_set_allocated:serum.CloseOpenOrderRequest.orders)
}

// -------------------------------------------------------------------

// CancelOrderRequest

// .basic.ProgramId dex_program_id = 1;
inline bool CancelOrderRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool CancelOrderRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& CancelOrderRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& CancelOrderRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.CancelOrderRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void CancelOrderRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CancelOrderRequest.dex_program_id)
}
inline ::basic::ProgramId* CancelOrderRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* CancelOrderRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.CancelOrderRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* CancelOrderRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* CancelOrderRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.CancelOrderRequest.dex_program_id)
  return _msg;
}
inline void CancelOrderRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.CancelOrderRequest.dex_program_id)
}

// .basic.Keypair owner = 2;
inline bool CancelOrderRequest::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool CancelOrderRequest::has_owner() const {
  return _internal_has_owner();
}
inline const ::basic::Keypair& CancelOrderRequest::_internal_owner() const {
  const ::basic::Keypair* p = owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& CancelOrderRequest::owner() const {
  // @@protoc_insertion_point(field_get:serum.CancelOrderRequest.owner)
  return _internal_owner();
}
inline void CancelOrderRequest::unsafe_arena_set_allocated_owner(
    ::basic::Keypair* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CancelOrderRequest.owner)
}
inline ::basic::Keypair* CancelOrderRequest::release_owner() {
  
  ::basic::Keypair* temp = owner_;
  owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* CancelOrderRequest::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:serum.CancelOrderRequest.owner)
  
  ::basic::Keypair* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::basic::Keypair* CancelOrderRequest::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    owner_ = p;
  }
  return owner_;
}
inline ::basic::Keypair* CancelOrderRequest::mutable_owner() {
  ::basic::Keypair* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:serum.CancelOrderRequest.owner)
  return _msg;
}
inline void CancelOrderRequest::set_allocated_owner(::basic::Keypair* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:serum.CancelOrderRequest.owner)
}

// .serum.MarketState market = 3;
inline bool CancelOrderRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool CancelOrderRequest::has_market() const {
  return _internal_has_market();
}
inline void CancelOrderRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& CancelOrderRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& CancelOrderRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.CancelOrderRequest.market)
  return _internal_market();
}
inline void CancelOrderRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CancelOrderRequest.market)
}
inline ::serum::MarketState* CancelOrderRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* CancelOrderRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.CancelOrderRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* CancelOrderRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* CancelOrderRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.CancelOrderRequest.market)
  return _msg;
}
inline void CancelOrderRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.CancelOrderRequest.market)
}

// .basic.Pubkey orders = 4;
inline bool CancelOrderRequest::_internal_has_orders() const {
  return this != internal_default_instance() && orders_ != nullptr;
}
inline bool CancelOrderRequest::has_orders() const {
  return _internal_has_orders();
}
inline const ::basic::Pubkey& CancelOrderRequest::_internal_orders() const {
  const ::basic::Pubkey* p = orders_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& CancelOrderRequest::orders() const {
  // @@protoc_insertion_point(field_get:serum.CancelOrderRequest.orders)
  return _internal_orders();
}
inline void CancelOrderRequest::unsafe_arena_set_allocated_orders(
    ::basic::Pubkey* orders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  orders_ = orders;
  if (orders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.CancelOrderRequest.orders)
}
inline ::basic::Pubkey* CancelOrderRequest::release_orders() {
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* CancelOrderRequest::unsafe_arena_release_orders() {
  // @@protoc_insertion_point(field_release:serum.CancelOrderRequest.orders)
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* CancelOrderRequest::_internal_mutable_orders() {
  
  if (orders_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    orders_ = p;
  }
  return orders_;
}
inline ::basic::Pubkey* CancelOrderRequest::mutable_orders() {
  ::basic::Pubkey* _msg = _internal_mutable_orders();
  // @@protoc_insertion_point(field_mutable:serum.CancelOrderRequest.orders)
  return _msg;
}
inline void CancelOrderRequest::set_allocated_orders(::basic::Pubkey* orders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  if (orders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders));
    if (message_arena != submessage_arena) {
      orders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orders, submessage_arena);
    }
    
  } else {
    
  }
  orders_ = orders;
  // @@protoc_insertion_point(field_set_allocated:serum.CancelOrderRequest.orders)
}

// uint64 id = 5;
inline void CancelOrderRequest::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t CancelOrderRequest::_internal_id() const {
  return id_;
}
inline uint64_t CancelOrderRequest::id() const {
  // @@protoc_insertion_point(field_get:serum.CancelOrderRequest.id)
  return _internal_id();
}
inline void CancelOrderRequest::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void CancelOrderRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:serum.CancelOrderRequest.id)
}

// -------------------------------------------------------------------

// ListMarketResponse

// .serum.MarketPubkeys market_pubkeys = 1;
inline bool ListMarketResponse::_internal_has_market_pubkeys() const {
  return this != internal_default_instance() && market_pubkeys_ != nullptr;
}
inline bool ListMarketResponse::has_market_pubkeys() const {
  return _internal_has_market_pubkeys();
}
inline void ListMarketResponse::clear_market_pubkeys() {
  if (GetArenaForAllocation() == nullptr && market_pubkeys_ != nullptr) {
    delete market_pubkeys_;
  }
  market_pubkeys_ = nullptr;
}
inline const ::serum::MarketPubkeys& ListMarketResponse::_internal_market_pubkeys() const {
  const ::serum::MarketPubkeys* p = market_pubkeys_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketPubkeys&>(
      ::serum::_MarketPubkeys_default_instance_);
}
inline const ::serum::MarketPubkeys& ListMarketResponse::market_pubkeys() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketResponse.market_pubkeys)
  return _internal_market_pubkeys();
}
inline void ListMarketResponse::unsafe_arena_set_allocated_market_pubkeys(
    ::serum::MarketPubkeys* market_pubkeys) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_pubkeys_);
  }
  market_pubkeys_ = market_pubkeys;
  if (market_pubkeys) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ListMarketResponse.market_pubkeys)
}
inline ::serum::MarketPubkeys* ListMarketResponse::release_market_pubkeys() {
  
  ::serum::MarketPubkeys* temp = market_pubkeys_;
  market_pubkeys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketPubkeys* ListMarketResponse::unsafe_arena_release_market_pubkeys() {
  // @@protoc_insertion_point(field_release:serum.ListMarketResponse.market_pubkeys)
  
  ::serum::MarketPubkeys* temp = market_pubkeys_;
  market_pubkeys_ = nullptr;
  return temp;
}
inline ::serum::MarketPubkeys* ListMarketResponse::_internal_mutable_market_pubkeys() {
  
  if (market_pubkeys_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketPubkeys>(GetArenaForAllocation());
    market_pubkeys_ = p;
  }
  return market_pubkeys_;
}
inline ::serum::MarketPubkeys* ListMarketResponse::mutable_market_pubkeys() {
  ::serum::MarketPubkeys* _msg = _internal_mutable_market_pubkeys();
  // @@protoc_insertion_point(field_mutable:serum.ListMarketResponse.market_pubkeys)
  return _msg;
}
inline void ListMarketResponse::set_allocated_market_pubkeys(::serum::MarketPubkeys* market_pubkeys) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_pubkeys_;
  }
  if (market_pubkeys) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketPubkeys>::GetOwningArena(market_pubkeys);
    if (message_arena != submessage_arena) {
      market_pubkeys = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_pubkeys, submessage_arena);
    }
    
  } else {
    
  }
  market_pubkeys_ = market_pubkeys;
  // @@protoc_insertion_point(field_set_allocated:serum.ListMarketResponse.market_pubkeys)
}

// .basic.SignedTx tx = 2;
inline bool ListMarketResponse::_internal_has_tx() const {
  return this != internal_default_instance() && tx_ != nullptr;
}
inline bool ListMarketResponse::has_tx() const {
  return _internal_has_tx();
}
inline const ::basic::SignedTx& ListMarketResponse::_internal_tx() const {
  const ::basic::SignedTx* p = tx_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::SignedTx&>(
      ::basic::_SignedTx_default_instance_);
}
inline const ::basic::SignedTx& ListMarketResponse::tx() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketResponse.tx)
  return _internal_tx();
}
inline void ListMarketResponse::unsafe_arena_set_allocated_tx(
    ::basic::SignedTx* tx) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tx_);
  }
  tx_ = tx;
  if (tx) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ListMarketResponse.tx)
}
inline ::basic::SignedTx* ListMarketResponse::release_tx() {
  
  ::basic::SignedTx* temp = tx_;
  tx_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::SignedTx* ListMarketResponse::unsafe_arena_release_tx() {
  // @@protoc_insertion_point(field_release:serum.ListMarketResponse.tx)
  
  ::basic::SignedTx* temp = tx_;
  tx_ = nullptr;
  return temp;
}
inline ::basic::SignedTx* ListMarketResponse::_internal_mutable_tx() {
  
  if (tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::SignedTx>(GetArenaForAllocation());
    tx_ = p;
  }
  return tx_;
}
inline ::basic::SignedTx* ListMarketResponse::mutable_tx() {
  ::basic::SignedTx* _msg = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:serum.ListMarketResponse.tx)
  return _msg;
}
inline void ListMarketResponse::set_allocated_tx(::basic::SignedTx* tx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tx_);
  }
  if (tx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tx));
    if (message_arena != submessage_arena) {
      tx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    
  } else {
    
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:serum.ListMarketResponse.tx)
}

// -------------------------------------------------------------------

// Order

// .serum.NewOrderInstructionV3 v3 = 1;
inline bool Order::_internal_has_v3() const {
  return order_case() == kV3;
}
inline bool Order::has_v3() const {
  return _internal_has_v3();
}
inline void Order::set_has_v3() {
  _oneof_case_[0] = kV3;
}
inline void Order::clear_v3() {
  if (_internal_has_v3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete order_.v3_;
    }
    clear_has_order();
  }
}
inline ::serum::NewOrderInstructionV3* Order::release_v3() {
  // @@protoc_insertion_point(field_release:serum.Order.v3)
  if (_internal_has_v3()) {
    clear_has_order();
      ::serum::NewOrderInstructionV3* temp = order_.v3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    order_.v3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::serum::NewOrderInstructionV3& Order::_internal_v3() const {
  return _internal_has_v3()
      ? *order_.v3_
      : reinterpret_cast< ::serum::NewOrderInstructionV3&>(::serum::_NewOrderInstructionV3_default_instance_);
}
inline const ::serum::NewOrderInstructionV3& Order::v3() const {
  // @@protoc_insertion_point(field_get:serum.Order.v3)
  return _internal_v3();
}
inline ::serum::NewOrderInstructionV3* Order::unsafe_arena_release_v3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serum.Order.v3)
  if (_internal_has_v3()) {
    clear_has_order();
    ::serum::NewOrderInstructionV3* temp = order_.v3_;
    order_.v3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Order::unsafe_arena_set_allocated_v3(::serum::NewOrderInstructionV3* v3) {
  clear_order();
  if (v3) {
    set_has_v3();
    order_.v3_ = v3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Order.v3)
}
inline ::serum::NewOrderInstructionV3* Order::_internal_mutable_v3() {
  if (!_internal_has_v3()) {
    clear_order();
    set_has_v3();
    order_.v3_ = CreateMaybeMessage< ::serum::NewOrderInstructionV3 >(GetArenaForAllocation());
  }
  return order_.v3_;
}
inline ::serum::NewOrderInstructionV3* Order::mutable_v3() {
  ::serum::NewOrderInstructionV3* _msg = _internal_mutable_v3();
  // @@protoc_insertion_point(field_mutable:serum.Order.v3)
  return _msg;
}

// .basic.ProgramId dex_program_id = 2;
inline bool Order::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool Order::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& Order::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& Order::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.Order.dex_program_id)
  return _internal_dex_program_id();
}
inline void Order::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Order.dex_program_id)
}
inline ::basic::ProgramId* Order::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* Order::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.Order.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* Order::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* Order::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.Order.dex_program_id)
  return _msg;
}
inline void Order::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.Order.dex_program_id)
}

// .basic.Keypair payer = 3;
inline bool Order::_internal_has_payer() const {
  return this != internal_default_instance() && payer_ != nullptr;
}
inline bool Order::has_payer() const {
  return _internal_has_payer();
}
inline const ::basic::Keypair& Order::_internal_payer() const {
  const ::basic::Keypair* p = payer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& Order::payer() const {
  // @@protoc_insertion_point(field_get:serum.Order.payer)
  return _internal_payer();
}
inline void Order::unsafe_arena_set_allocated_payer(
    ::basic::Keypair* payer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  payer_ = payer;
  if (payer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Order.payer)
}
inline ::basic::Keypair* Order::release_payer() {
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* Order::unsafe_arena_release_payer() {
  // @@protoc_insertion_point(field_release:serum.Order.payer)
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* Order::_internal_mutable_payer() {
  
  if (payer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    payer_ = p;
  }
  return payer_;
}
inline ::basic::Keypair* Order::mutable_payer() {
  ::basic::Keypair* _msg = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:serum.Order.payer)
  return _msg;
}
inline void Order::set_allocated_payer(::basic::Keypair* payer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  if (payer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer));
    if (message_arena != submessage_arena) {
      payer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payer, submessage_arena);
    }
    
  } else {
    
  }
  payer_ = payer;
  // @@protoc_insertion_point(field_set_allocated:serum.Order.payer)
}

// .basic.Pubkey wallet = 4;
inline bool Order::_internal_has_wallet() const {
  return this != internal_default_instance() && wallet_ != nullptr;
}
inline bool Order::has_wallet() const {
  return _internal_has_wallet();
}
inline const ::basic::Pubkey& Order::_internal_wallet() const {
  const ::basic::Pubkey* p = wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& Order::wallet() const {
  // @@protoc_insertion_point(field_get:serum.Order.wallet)
  return _internal_wallet();
}
inline void Order::unsafe_arena_set_allocated_wallet(
    ::basic::Pubkey* wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wallet_);
  }
  wallet_ = wallet;
  if (wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Order.wallet)
}
inline ::basic::Pubkey* Order::release_wallet() {
  
  ::basic::Pubkey* temp = wallet_;
  wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* Order::unsafe_arena_release_wallet() {
  // @@protoc_insertion_point(field_release:serum.Order.wallet)
  
  ::basic::Pubkey* temp = wallet_;
  wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* Order::_internal_mutable_wallet() {
  
  if (wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    wallet_ = p;
  }
  return wallet_;
}
inline ::basic::Pubkey* Order::mutable_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_wallet();
  // @@protoc_insertion_point(field_mutable:serum.Order.wallet)
  return _msg;
}
inline void Order::set_allocated_wallet(::basic::Pubkey* wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(wallet_);
  }
  if (wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wallet));
    if (message_arena != submessage_arena) {
      wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wallet, submessage_arena);
    }
    
  } else {
    
  }
  wallet_ = wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.Order.wallet)
}

// .serum.MarketState market = 5;
inline bool Order::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool Order::has_market() const {
  return _internal_has_market();
}
inline void Order::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& Order::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& Order::market() const {
  // @@protoc_insertion_point(field_get:serum.Order.market)
  return _internal_market();
}
inline void Order::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Order.market)
}
inline ::serum::MarketState* Order::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* Order::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.Order.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* Order::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* Order::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.Order.market)
  return _msg;
}
inline void Order::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.Order.market)
}

// .basic.Pubkey orders = 6;
inline bool Order::_internal_has_orders() const {
  return this != internal_default_instance() && orders_ != nullptr;
}
inline bool Order::has_orders() const {
  return _internal_has_orders();
}
inline const ::basic::Pubkey& Order::_internal_orders() const {
  const ::basic::Pubkey* p = orders_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& Order::orders() const {
  // @@protoc_insertion_point(field_get:serum.Order.orders)
  return _internal_orders();
}
inline void Order::unsafe_arena_set_allocated_orders(
    ::basic::Pubkey* orders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  orders_ = orders;
  if (orders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Order.orders)
}
inline ::basic::Pubkey* Order::release_orders() {
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* Order::unsafe_arena_release_orders() {
  // @@protoc_insertion_point(field_release:serum.Order.orders)
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* Order::_internal_mutable_orders() {
  
  if (orders_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    orders_ = p;
  }
  return orders_;
}
inline ::basic::Pubkey* Order::mutable_orders() {
  ::basic::Pubkey* _msg = _internal_mutable_orders();
  // @@protoc_insertion_point(field_mutable:serum.Order.orders)
  return _msg;
}
inline void Order::set_allocated_orders(::basic::Pubkey* orders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  if (orders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders));
    if (message_arena != submessage_arena) {
      orders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orders, submessage_arena);
    }
    
  } else {
    
  }
  orders_ = orders;
  // @@protoc_insertion_point(field_set_allocated:serum.Order.orders)
}

inline bool Order::has_order() const {
  return order_case() != ORDER_NOT_SET;
}
inline void Order::clear_has_order() {
  _oneof_case_[0] = ORDER_NOT_SET;
}
inline Order::OrderCase Order::order_case() const {
  return Order::OrderCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OrderStatus

// .basic.TxStatusWithSlot status_with_slot = 1;
inline bool OrderStatus::_internal_has_status_with_slot() const {
  return this != internal_default_instance() && status_with_slot_ != nullptr;
}
inline bool OrderStatus::has_status_with_slot() const {
  return _internal_has_status_with_slot();
}
inline const ::basic::TxStatusWithSlot& OrderStatus::_internal_status_with_slot() const {
  const ::basic::TxStatusWithSlot* p = status_with_slot_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::TxStatusWithSlot&>(
      ::basic::_TxStatusWithSlot_default_instance_);
}
inline const ::basic::TxStatusWithSlot& OrderStatus::status_with_slot() const {
  // @@protoc_insertion_point(field_get:serum.OrderStatus.status_with_slot)
  return _internal_status_with_slot();
}
inline void OrderStatus::unsafe_arena_set_allocated_status_with_slot(
    ::basic::TxStatusWithSlot* status_with_slot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_with_slot_);
  }
  status_with_slot_ = status_with_slot;
  if (status_with_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.OrderStatus.status_with_slot)
}
inline ::basic::TxStatusWithSlot* OrderStatus::release_status_with_slot() {
  
  ::basic::TxStatusWithSlot* temp = status_with_slot_;
  status_with_slot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::TxStatusWithSlot* OrderStatus::unsafe_arena_release_status_with_slot() {
  // @@protoc_insertion_point(field_release:serum.OrderStatus.status_with_slot)
  
  ::basic::TxStatusWithSlot* temp = status_with_slot_;
  status_with_slot_ = nullptr;
  return temp;
}
inline ::basic::TxStatusWithSlot* OrderStatus::_internal_mutable_status_with_slot() {
  
  if (status_with_slot_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::TxStatusWithSlot>(GetArenaForAllocation());
    status_with_slot_ = p;
  }
  return status_with_slot_;
}
inline ::basic::TxStatusWithSlot* OrderStatus::mutable_status_with_slot() {
  ::basic::TxStatusWithSlot* _msg = _internal_mutable_status_with_slot();
  // @@protoc_insertion_point(field_mutable:serum.OrderStatus.status_with_slot)
  return _msg;
}
inline void OrderStatus::set_allocated_status_with_slot(::basic::TxStatusWithSlot* status_with_slot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_with_slot_);
  }
  if (status_with_slot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_with_slot));
    if (message_arena != submessage_arena) {
      status_with_slot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_with_slot, submessage_arena);
    }
    
  } else {
    
  }
  status_with_slot_ = status_with_slot;
  // @@protoc_insertion_point(field_set_allocated:serum.OrderStatus.status_with_slot)
}

// -------------------------------------------------------------------

// NewOrderInstructionV3

// bool side = 1;
inline void NewOrderInstructionV3::clear_side() {
  side_ = false;
}
inline bool NewOrderInstructionV3::_internal_side() const {
  return side_;
}
inline bool NewOrderInstructionV3::side() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.side)
  return _internal_side();
}
inline void NewOrderInstructionV3::_internal_set_side(bool value) {
  
  side_ = value;
}
inline void NewOrderInstructionV3::set_side(bool value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.side)
}

// uint64 limit_price = 2;
inline void NewOrderInstructionV3::clear_limit_price() {
  limit_price_ = uint64_t{0u};
}
inline uint64_t NewOrderInstructionV3::_internal_limit_price() const {
  return limit_price_;
}
inline uint64_t NewOrderInstructionV3::limit_price() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.limit_price)
  return _internal_limit_price();
}
inline void NewOrderInstructionV3::_internal_set_limit_price(uint64_t value) {
  
  limit_price_ = value;
}
inline void NewOrderInstructionV3::set_limit_price(uint64_t value) {
  _internal_set_limit_price(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.limit_price)
}

// uint64 max_coin_qty = 3;
inline void NewOrderInstructionV3::clear_max_coin_qty() {
  max_coin_qty_ = uint64_t{0u};
}
inline uint64_t NewOrderInstructionV3::_internal_max_coin_qty() const {
  return max_coin_qty_;
}
inline uint64_t NewOrderInstructionV3::max_coin_qty() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.max_coin_qty)
  return _internal_max_coin_qty();
}
inline void NewOrderInstructionV3::_internal_set_max_coin_qty(uint64_t value) {
  
  max_coin_qty_ = value;
}
inline void NewOrderInstructionV3::set_max_coin_qty(uint64_t value) {
  _internal_set_max_coin_qty(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.max_coin_qty)
}

// uint64 max_native_pc_qty_including_fees = 4;
inline void NewOrderInstructionV3::clear_max_native_pc_qty_including_fees() {
  max_native_pc_qty_including_fees_ = uint64_t{0u};
}
inline uint64_t NewOrderInstructionV3::_internal_max_native_pc_qty_including_fees() const {
  return max_native_pc_qty_including_fees_;
}
inline uint64_t NewOrderInstructionV3::max_native_pc_qty_including_fees() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.max_native_pc_qty_including_fees)
  return _internal_max_native_pc_qty_including_fees();
}
inline void NewOrderInstructionV3::_internal_set_max_native_pc_qty_including_fees(uint64_t value) {
  
  max_native_pc_qty_including_fees_ = value;
}
inline void NewOrderInstructionV3::set_max_native_pc_qty_including_fees(uint64_t value) {
  _internal_set_max_native_pc_qty_including_fees(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.max_native_pc_qty_including_fees)
}

// .serum.SelfTradeBehavior self_trade_behavior = 5;
inline void NewOrderInstructionV3::clear_self_trade_behavior() {
  self_trade_behavior_ = 0;
}
inline ::serum::SelfTradeBehavior NewOrderInstructionV3::_internal_self_trade_behavior() const {
  return static_cast< ::serum::SelfTradeBehavior >(self_trade_behavior_);
}
inline ::serum::SelfTradeBehavior NewOrderInstructionV3::self_trade_behavior() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.self_trade_behavior)
  return _internal_self_trade_behavior();
}
inline void NewOrderInstructionV3::_internal_set_self_trade_behavior(::serum::SelfTradeBehavior value) {
  
  self_trade_behavior_ = value;
}
inline void NewOrderInstructionV3::set_self_trade_behavior(::serum::SelfTradeBehavior value) {
  _internal_set_self_trade_behavior(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.self_trade_behavior)
}

// .serum.OrderType order_type = 6;
inline void NewOrderInstructionV3::clear_order_type() {
  order_type_ = 0;
}
inline ::serum::OrderType NewOrderInstructionV3::_internal_order_type() const {
  return static_cast< ::serum::OrderType >(order_type_);
}
inline ::serum::OrderType NewOrderInstructionV3::order_type() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.order_type)
  return _internal_order_type();
}
inline void NewOrderInstructionV3::_internal_set_order_type(::serum::OrderType value) {
  
  order_type_ = value;
}
inline void NewOrderInstructionV3::set_order_type(::serum::OrderType value) {
  _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.order_type)
}

// uint64 client_order_id = 7;
inline void NewOrderInstructionV3::clear_client_order_id() {
  client_order_id_ = uint64_t{0u};
}
inline uint64_t NewOrderInstructionV3::_internal_client_order_id() const {
  return client_order_id_;
}
inline uint64_t NewOrderInstructionV3::client_order_id() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.client_order_id)
  return _internal_client_order_id();
}
inline void NewOrderInstructionV3::_internal_set_client_order_id(uint64_t value) {
  
  client_order_id_ = value;
}
inline void NewOrderInstructionV3::set_client_order_id(uint64_t value) {
  _internal_set_client_order_id(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.client_order_id)
}

// uint32 limit = 8;
inline void NewOrderInstructionV3::clear_limit() {
  limit_ = 0u;
}
inline uint32_t NewOrderInstructionV3::_internal_limit() const {
  return limit_;
}
inline uint32_t NewOrderInstructionV3::limit() const {
  // @@protoc_insertion_point(field_get:serum.NewOrderInstructionV3.limit)
  return _internal_limit();
}
inline void NewOrderInstructionV3::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void NewOrderInstructionV3::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:serum.NewOrderInstructionV3.limit)
}

// -------------------------------------------------------------------

// Event

// .serum.Bid bid = 1;
inline bool Event::_internal_has_bid() const {
  return event_case() == kBid;
}
inline bool Event::has_bid() const {
  return _internal_has_bid();
}
inline void Event::set_has_bid() {
  _oneof_case_[0] = kBid;
}
inline void Event::clear_bid() {
  if (_internal_has_bid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.bid_;
    }
    clear_has_event();
  }
}
inline ::serum::Bid* Event::release_bid() {
  // @@protoc_insertion_point(field_release:serum.Event.bid)
  if (_internal_has_bid()) {
    clear_has_event();
      ::serum::Bid* temp = event_.bid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.bid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::serum::Bid& Event::_internal_bid() const {
  return _internal_has_bid()
      ? *event_.bid_
      : reinterpret_cast< ::serum::Bid&>(::serum::_Bid_default_instance_);
}
inline const ::serum::Bid& Event::bid() const {
  // @@protoc_insertion_point(field_get:serum.Event.bid)
  return _internal_bid();
}
inline ::serum::Bid* Event::unsafe_arena_release_bid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serum.Event.bid)
  if (_internal_has_bid()) {
    clear_has_event();
    ::serum::Bid* temp = event_.bid_;
    event_.bid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_bid(::serum::Bid* bid) {
  clear_event();
  if (bid) {
    set_has_bid();
    event_.bid_ = bid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Event.bid)
}
inline ::serum::Bid* Event::_internal_mutable_bid() {
  if (!_internal_has_bid()) {
    clear_event();
    set_has_bid();
    event_.bid_ = CreateMaybeMessage< ::serum::Bid >(GetArenaForAllocation());
  }
  return event_.bid_;
}
inline ::serum::Bid* Event::mutable_bid() {
  ::serum::Bid* _msg = _internal_mutable_bid();
  // @@protoc_insertion_point(field_mutable:serum.Event.bid)
  return _msg;
}

// .serum.Ask ask = 2;
inline bool Event::_internal_has_ask() const {
  return event_case() == kAsk;
}
inline bool Event::has_ask() const {
  return _internal_has_ask();
}
inline void Event::set_has_ask() {
  _oneof_case_[0] = kAsk;
}
inline void Event::clear_ask() {
  if (_internal_has_ask()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.ask_;
    }
    clear_has_event();
  }
}
inline ::serum::Ask* Event::release_ask() {
  // @@protoc_insertion_point(field_release:serum.Event.ask)
  if (_internal_has_ask()) {
    clear_has_event();
      ::serum::Ask* temp = event_.ask_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.ask_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::serum::Ask& Event::_internal_ask() const {
  return _internal_has_ask()
      ? *event_.ask_
      : reinterpret_cast< ::serum::Ask&>(::serum::_Ask_default_instance_);
}
inline const ::serum::Ask& Event::ask() const {
  // @@protoc_insertion_point(field_get:serum.Event.ask)
  return _internal_ask();
}
inline ::serum::Ask* Event::unsafe_arena_release_ask() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serum.Event.ask)
  if (_internal_has_ask()) {
    clear_has_event();
    ::serum::Ask* temp = event_.ask_;
    event_.ask_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_ask(::serum::Ask* ask) {
  clear_event();
  if (ask) {
    set_has_ask();
    event_.ask_ = ask;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.Event.ask)
}
inline ::serum::Ask* Event::_internal_mutable_ask() {
  if (!_internal_has_ask()) {
    clear_event();
    set_has_ask();
    event_.ask_ = CreateMaybeMessage< ::serum::Ask >(GetArenaForAllocation());
  }
  return event_.ask_;
}
inline ::serum::Ask* Event::mutable_ask() {
  ::serum::Ask* _msg = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:serum.Event.ask)
  return _msg;
}

inline bool Event::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void Event::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline Event::EventCase Event::event_case() const {
  return Event::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Bid

// -------------------------------------------------------------------

// Ask

// -------------------------------------------------------------------

// ConsumeEventUpdate

// int64 crank_count = 1;
inline void ConsumeEventUpdate::clear_crank_count() {
  crank_count_ = int64_t{0};
}
inline int64_t ConsumeEventUpdate::_internal_crank_count() const {
  return crank_count_;
}
inline int64_t ConsumeEventUpdate::crank_count() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventUpdate.crank_count)
  return _internal_crank_count();
}
inline void ConsumeEventUpdate::_internal_set_crank_count(int64_t value) {
  
  crank_count_ = value;
}
inline void ConsumeEventUpdate::set_crank_count(int64_t value) {
  _internal_set_crank_count(value);
  // @@protoc_insertion_point(field_set:serum.ConsumeEventUpdate.crank_count)
}

// string status = 2;
inline void ConsumeEventUpdate::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ConsumeEventUpdate::status() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventUpdate.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsumeEventUpdate::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:serum.ConsumeEventUpdate.status)
}
inline std::string* ConsumeEventUpdate::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventUpdate.status)
  return _s;
}
inline const std::string& ConsumeEventUpdate::_internal_status() const {
  return status_.Get();
}
inline void ConsumeEventUpdate::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsumeEventUpdate::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsumeEventUpdate::release_status() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventUpdate.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsumeEventUpdate::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventUpdate.status)
}

// -------------------------------------------------------------------

// MarketPubkeys

// .basic.Pubkey market = 1;
inline bool MarketPubkeys::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool MarketPubkeys::has_market() const {
  return _internal_has_market();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_market() const {
  const ::basic::Pubkey* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::market() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.market)
  return _internal_market();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_market(
    ::basic::Pubkey* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.market)
}
inline ::basic::Pubkey* MarketPubkeys::release_market() {
  
  ::basic::Pubkey* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.market)
  
  ::basic::Pubkey* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_market() {
  ::basic::Pubkey* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.market)
  return _msg;
}
inline void MarketPubkeys::set_allocated_market(::basic::Pubkey* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.market)
}

// .basic.Pubkey req_q = 2;
inline bool MarketPubkeys::_internal_has_req_q() const {
  return this != internal_default_instance() && req_q_ != nullptr;
}
inline bool MarketPubkeys::has_req_q() const {
  return _internal_has_req_q();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_req_q() const {
  const ::basic::Pubkey* p = req_q_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::req_q() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.req_q)
  return _internal_req_q();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_req_q(
    ::basic::Pubkey* req_q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_q_);
  }
  req_q_ = req_q;
  if (req_q) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.req_q)
}
inline ::basic::Pubkey* MarketPubkeys::release_req_q() {
  
  ::basic::Pubkey* temp = req_q_;
  req_q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_req_q() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.req_q)
  
  ::basic::Pubkey* temp = req_q_;
  req_q_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_req_q() {
  
  if (req_q_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    req_q_ = p;
  }
  return req_q_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_req_q() {
  ::basic::Pubkey* _msg = _internal_mutable_req_q();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.req_q)
  return _msg;
}
inline void MarketPubkeys::set_allocated_req_q(::basic::Pubkey* req_q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_q_);
  }
  if (req_q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_q));
    if (message_arena != submessage_arena) {
      req_q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req_q, submessage_arena);
    }
    
  } else {
    
  }
  req_q_ = req_q;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.req_q)
}

// .basic.Pubkey event_q = 3;
inline bool MarketPubkeys::_internal_has_event_q() const {
  return this != internal_default_instance() && event_q_ != nullptr;
}
inline bool MarketPubkeys::has_event_q() const {
  return _internal_has_event_q();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_event_q() const {
  const ::basic::Pubkey* p = event_q_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::event_q() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.event_q)
  return _internal_event_q();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_event_q(
    ::basic::Pubkey* event_q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_q_);
  }
  event_q_ = event_q;
  if (event_q) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.event_q)
}
inline ::basic::Pubkey* MarketPubkeys::release_event_q() {
  
  ::basic::Pubkey* temp = event_q_;
  event_q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_event_q() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.event_q)
  
  ::basic::Pubkey* temp = event_q_;
  event_q_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_event_q() {
  
  if (event_q_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    event_q_ = p;
  }
  return event_q_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_event_q() {
  ::basic::Pubkey* _msg = _internal_mutable_event_q();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.event_q)
  return _msg;
}
inline void MarketPubkeys::set_allocated_event_q(::basic::Pubkey* event_q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_q_);
  }
  if (event_q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_q));
    if (message_arena != submessage_arena) {
      event_q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_q, submessage_arena);
    }
    
  } else {
    
  }
  event_q_ = event_q;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.event_q)
}

// .basic.Pubkey bids = 4;
inline bool MarketPubkeys::_internal_has_bids() const {
  return this != internal_default_instance() && bids_ != nullptr;
}
inline bool MarketPubkeys::has_bids() const {
  return _internal_has_bids();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_bids() const {
  const ::basic::Pubkey* p = bids_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::bids() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.bids)
  return _internal_bids();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_bids(
    ::basic::Pubkey* bids) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bids_);
  }
  bids_ = bids;
  if (bids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.bids)
}
inline ::basic::Pubkey* MarketPubkeys::release_bids() {
  
  ::basic::Pubkey* temp = bids_;
  bids_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_bids() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.bids)
  
  ::basic::Pubkey* temp = bids_;
  bids_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_bids() {
  
  if (bids_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    bids_ = p;
  }
  return bids_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_bids() {
  ::basic::Pubkey* _msg = _internal_mutable_bids();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.bids)
  return _msg;
}
inline void MarketPubkeys::set_allocated_bids(::basic::Pubkey* bids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bids_);
  }
  if (bids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bids));
    if (message_arena != submessage_arena) {
      bids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bids, submessage_arena);
    }
    
  } else {
    
  }
  bids_ = bids;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.bids)
}

// .basic.Pubkey asks = 5;
inline bool MarketPubkeys::_internal_has_asks() const {
  return this != internal_default_instance() && asks_ != nullptr;
}
inline bool MarketPubkeys::has_asks() const {
  return _internal_has_asks();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_asks() const {
  const ::basic::Pubkey* p = asks_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::asks() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.asks)
  return _internal_asks();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_asks(
    ::basic::Pubkey* asks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asks_);
  }
  asks_ = asks;
  if (asks) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.asks)
}
inline ::basic::Pubkey* MarketPubkeys::release_asks() {
  
  ::basic::Pubkey* temp = asks_;
  asks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_asks() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.asks)
  
  ::basic::Pubkey* temp = asks_;
  asks_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_asks() {
  
  if (asks_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    asks_ = p;
  }
  return asks_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_asks() {
  ::basic::Pubkey* _msg = _internal_mutable_asks();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.asks)
  return _msg;
}
inline void MarketPubkeys::set_allocated_asks(::basic::Pubkey* asks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(asks_);
  }
  if (asks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asks));
    if (message_arena != submessage_arena) {
      asks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asks, submessage_arena);
    }
    
  } else {
    
  }
  asks_ = asks;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.asks)
}

// .basic.Pubkey coin_vault = 6;
inline bool MarketPubkeys::_internal_has_coin_vault() const {
  return this != internal_default_instance() && coin_vault_ != nullptr;
}
inline bool MarketPubkeys::has_coin_vault() const {
  return _internal_has_coin_vault();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_coin_vault() const {
  const ::basic::Pubkey* p = coin_vault_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::coin_vault() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.coin_vault)
  return _internal_coin_vault();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_coin_vault(
    ::basic::Pubkey* coin_vault) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_vault_);
  }
  coin_vault_ = coin_vault;
  if (coin_vault) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.coin_vault)
}
inline ::basic::Pubkey* MarketPubkeys::release_coin_vault() {
  
  ::basic::Pubkey* temp = coin_vault_;
  coin_vault_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_coin_vault() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.coin_vault)
  
  ::basic::Pubkey* temp = coin_vault_;
  coin_vault_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_coin_vault() {
  
  if (coin_vault_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    coin_vault_ = p;
  }
  return coin_vault_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_coin_vault() {
  ::basic::Pubkey* _msg = _internal_mutable_coin_vault();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.coin_vault)
  return _msg;
}
inline void MarketPubkeys::set_allocated_coin_vault(::basic::Pubkey* coin_vault) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_vault_);
  }
  if (coin_vault) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_vault));
    if (message_arena != submessage_arena) {
      coin_vault = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_vault, submessage_arena);
    }
    
  } else {
    
  }
  coin_vault_ = coin_vault;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.coin_vault)
}

// .basic.Pubkey pc_vault = 7;
inline bool MarketPubkeys::_internal_has_pc_vault() const {
  return this != internal_default_instance() && pc_vault_ != nullptr;
}
inline bool MarketPubkeys::has_pc_vault() const {
  return _internal_has_pc_vault();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_pc_vault() const {
  const ::basic::Pubkey* p = pc_vault_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::pc_vault() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.pc_vault)
  return _internal_pc_vault();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_pc_vault(
    ::basic::Pubkey* pc_vault) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_vault_);
  }
  pc_vault_ = pc_vault;
  if (pc_vault) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.pc_vault)
}
inline ::basic::Pubkey* MarketPubkeys::release_pc_vault() {
  
  ::basic::Pubkey* temp = pc_vault_;
  pc_vault_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_pc_vault() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.pc_vault)
  
  ::basic::Pubkey* temp = pc_vault_;
  pc_vault_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_pc_vault() {
  
  if (pc_vault_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    pc_vault_ = p;
  }
  return pc_vault_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_pc_vault() {
  ::basic::Pubkey* _msg = _internal_mutable_pc_vault();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.pc_vault)
  return _msg;
}
inline void MarketPubkeys::set_allocated_pc_vault(::basic::Pubkey* pc_vault) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_vault_);
  }
  if (pc_vault) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_vault));
    if (message_arena != submessage_arena) {
      pc_vault = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pc_vault, submessage_arena);
    }
    
  } else {
    
  }
  pc_vault_ = pc_vault;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.pc_vault)
}

// .basic.Pubkey vault_signer_key = 8;
inline bool MarketPubkeys::_internal_has_vault_signer_key() const {
  return this != internal_default_instance() && vault_signer_key_ != nullptr;
}
inline bool MarketPubkeys::has_vault_signer_key() const {
  return _internal_has_vault_signer_key();
}
inline const ::basic::Pubkey& MarketPubkeys::_internal_vault_signer_key() const {
  const ::basic::Pubkey* p = vault_signer_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketPubkeys::vault_signer_key() const {
  // @@protoc_insertion_point(field_get:serum.MarketPubkeys.vault_signer_key)
  return _internal_vault_signer_key();
}
inline void MarketPubkeys::unsafe_arena_set_allocated_vault_signer_key(
    ::basic::Pubkey* vault_signer_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vault_signer_key_);
  }
  vault_signer_key_ = vault_signer_key;
  if (vault_signer_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketPubkeys.vault_signer_key)
}
inline ::basic::Pubkey* MarketPubkeys::release_vault_signer_key() {
  
  ::basic::Pubkey* temp = vault_signer_key_;
  vault_signer_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::unsafe_arena_release_vault_signer_key() {
  // @@protoc_insertion_point(field_release:serum.MarketPubkeys.vault_signer_key)
  
  ::basic::Pubkey* temp = vault_signer_key_;
  vault_signer_key_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketPubkeys::_internal_mutable_vault_signer_key() {
  
  if (vault_signer_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    vault_signer_key_ = p;
  }
  return vault_signer_key_;
}
inline ::basic::Pubkey* MarketPubkeys::mutable_vault_signer_key() {
  ::basic::Pubkey* _msg = _internal_mutable_vault_signer_key();
  // @@protoc_insertion_point(field_mutable:serum.MarketPubkeys.vault_signer_key)
  return _msg;
}
inline void MarketPubkeys::set_allocated_vault_signer_key(::basic::Pubkey* vault_signer_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vault_signer_key_);
  }
  if (vault_signer_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vault_signer_key));
    if (message_arena != submessage_arena) {
      vault_signer_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vault_signer_key, submessage_arena);
    }
    
  } else {
    
  }
  vault_signer_key_ = vault_signer_key;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketPubkeys.vault_signer_key)
}

// -------------------------------------------------------------------

// ConsumeEventsRequest

// .basic.ProgramId dex_program_id = 1;
inline bool ConsumeEventsRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool ConsumeEventsRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& ConsumeEventsRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& ConsumeEventsRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void ConsumeEventsRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ConsumeEventsRequest.dex_program_id)
}
inline ::basic::ProgramId* ConsumeEventsRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* ConsumeEventsRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventsRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* ConsumeEventsRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* ConsumeEventsRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventsRequest.dex_program_id)
  return _msg;
}
inline void ConsumeEventsRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventsRequest.dex_program_id)
}

// .basic.Keypair payer = 2;
inline bool ConsumeEventsRequest::_internal_has_payer() const {
  return this != internal_default_instance() && payer_ != nullptr;
}
inline bool ConsumeEventsRequest::has_payer() const {
  return _internal_has_payer();
}
inline const ::basic::Keypair& ConsumeEventsRequest::_internal_payer() const {
  const ::basic::Keypair* p = payer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& ConsumeEventsRequest::payer() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.payer)
  return _internal_payer();
}
inline void ConsumeEventsRequest::unsafe_arena_set_allocated_payer(
    ::basic::Keypair* payer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  payer_ = payer;
  if (payer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ConsumeEventsRequest.payer)
}
inline ::basic::Keypair* ConsumeEventsRequest::release_payer() {
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* ConsumeEventsRequest::unsafe_arena_release_payer() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventsRequest.payer)
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* ConsumeEventsRequest::_internal_mutable_payer() {
  
  if (payer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    payer_ = p;
  }
  return payer_;
}
inline ::basic::Keypair* ConsumeEventsRequest::mutable_payer() {
  ::basic::Keypair* _msg = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventsRequest.payer)
  return _msg;
}
inline void ConsumeEventsRequest::set_allocated_payer(::basic::Keypair* payer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  if (payer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer));
    if (message_arena != submessage_arena) {
      payer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payer, submessage_arena);
    }
    
  } else {
    
  }
  payer_ = payer;
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventsRequest.payer)
}

// .serum.MarketState market = 3;
inline bool ConsumeEventsRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool ConsumeEventsRequest::has_market() const {
  return _internal_has_market();
}
inline void ConsumeEventsRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& ConsumeEventsRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& ConsumeEventsRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.market)
  return _internal_market();
}
inline void ConsumeEventsRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ConsumeEventsRequest.market)
}
inline ::serum::MarketState* ConsumeEventsRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* ConsumeEventsRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventsRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* ConsumeEventsRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* ConsumeEventsRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventsRequest.market)
  return _msg;
}
inline void ConsumeEventsRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventsRequest.market)
}

// .basic.Pubkey coin_wallet = 4;
inline bool ConsumeEventsRequest::_internal_has_coin_wallet() const {
  return this != internal_default_instance() && coin_wallet_ != nullptr;
}
inline bool ConsumeEventsRequest::has_coin_wallet() const {
  return _internal_has_coin_wallet();
}
inline const ::basic::Pubkey& ConsumeEventsRequest::_internal_coin_wallet() const {
  const ::basic::Pubkey* p = coin_wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& ConsumeEventsRequest::coin_wallet() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.coin_wallet)
  return _internal_coin_wallet();
}
inline void ConsumeEventsRequest::unsafe_arena_set_allocated_coin_wallet(
    ::basic::Pubkey* coin_wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet_);
  }
  coin_wallet_ = coin_wallet;
  if (coin_wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ConsumeEventsRequest.coin_wallet)
}
inline ::basic::Pubkey* ConsumeEventsRequest::release_coin_wallet() {
  
  ::basic::Pubkey* temp = coin_wallet_;
  coin_wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* ConsumeEventsRequest::unsafe_arena_release_coin_wallet() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventsRequest.coin_wallet)
  
  ::basic::Pubkey* temp = coin_wallet_;
  coin_wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* ConsumeEventsRequest::_internal_mutable_coin_wallet() {
  
  if (coin_wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    coin_wallet_ = p;
  }
  return coin_wallet_;
}
inline ::basic::Pubkey* ConsumeEventsRequest::mutable_coin_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_coin_wallet();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventsRequest.coin_wallet)
  return _msg;
}
inline void ConsumeEventsRequest::set_allocated_coin_wallet(::basic::Pubkey* coin_wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet_);
  }
  if (coin_wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet));
    if (message_arena != submessage_arena) {
      coin_wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_wallet, submessage_arena);
    }
    
  } else {
    
  }
  coin_wallet_ = coin_wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventsRequest.coin_wallet)
}

// .basic.Pubkey pc_wallet = 5;
inline bool ConsumeEventsRequest::_internal_has_pc_wallet() const {
  return this != internal_default_instance() && pc_wallet_ != nullptr;
}
inline bool ConsumeEventsRequest::has_pc_wallet() const {
  return _internal_has_pc_wallet();
}
inline const ::basic::Pubkey& ConsumeEventsRequest::_internal_pc_wallet() const {
  const ::basic::Pubkey* p = pc_wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& ConsumeEventsRequest::pc_wallet() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.pc_wallet)
  return _internal_pc_wallet();
}
inline void ConsumeEventsRequest::unsafe_arena_set_allocated_pc_wallet(
    ::basic::Pubkey* pc_wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet_);
  }
  pc_wallet_ = pc_wallet;
  if (pc_wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ConsumeEventsRequest.pc_wallet)
}
inline ::basic::Pubkey* ConsumeEventsRequest::release_pc_wallet() {
  
  ::basic::Pubkey* temp = pc_wallet_;
  pc_wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* ConsumeEventsRequest::unsafe_arena_release_pc_wallet() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventsRequest.pc_wallet)
  
  ::basic::Pubkey* temp = pc_wallet_;
  pc_wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* ConsumeEventsRequest::_internal_mutable_pc_wallet() {
  
  if (pc_wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    pc_wallet_ = p;
  }
  return pc_wallet_;
}
inline ::basic::Pubkey* ConsumeEventsRequest::mutable_pc_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_pc_wallet();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventsRequest.pc_wallet)
  return _msg;
}
inline void ConsumeEventsRequest::set_allocated_pc_wallet(::basic::Pubkey* pc_wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet_);
  }
  if (pc_wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet));
    if (message_arena != submessage_arena) {
      pc_wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pc_wallet, submessage_arena);
    }
    
  } else {
    
  }
  pc_wallet_ = pc_wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventsRequest.pc_wallet)
}

// uint64 num_workers = 6;
inline void ConsumeEventsRequest::clear_num_workers() {
  num_workers_ = uint64_t{0u};
}
inline uint64_t ConsumeEventsRequest::_internal_num_workers() const {
  return num_workers_;
}
inline uint64_t ConsumeEventsRequest::num_workers() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.num_workers)
  return _internal_num_workers();
}
inline void ConsumeEventsRequest::_internal_set_num_workers(uint64_t value) {
  
  num_workers_ = value;
}
inline void ConsumeEventsRequest::set_num_workers(uint64_t value) {
  _internal_set_num_workers(value);
  // @@protoc_insertion_point(field_set:serum.ConsumeEventsRequest.num_workers)
}

// uint64 events_per_worker = 7;
inline void ConsumeEventsRequest::clear_events_per_worker() {
  events_per_worker_ = uint64_t{0u};
}
inline uint64_t ConsumeEventsRequest::_internal_events_per_worker() const {
  return events_per_worker_;
}
inline uint64_t ConsumeEventsRequest::events_per_worker() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.events_per_worker)
  return _internal_events_per_worker();
}
inline void ConsumeEventsRequest::_internal_set_events_per_worker(uint64_t value) {
  
  events_per_worker_ = value;
}
inline void ConsumeEventsRequest::set_events_per_worker(uint64_t value) {
  _internal_set_events_per_worker(value);
  // @@protoc_insertion_point(field_set:serum.ConsumeEventsRequest.events_per_worker)
}

// uint64 num_accounts = 8;
inline void ConsumeEventsRequest::clear_num_accounts() {
  num_accounts_ = uint64_t{0u};
}
inline uint64_t ConsumeEventsRequest::_internal_num_accounts() const {
  return num_accounts_;
}
inline uint64_t ConsumeEventsRequest::num_accounts() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.num_accounts)
  return _internal_num_accounts();
}
inline void ConsumeEventsRequest::_internal_set_num_accounts(uint64_t value) {
  
  num_accounts_ = value;
}
inline void ConsumeEventsRequest::set_num_accounts(uint64_t value) {
  _internal_set_num_accounts(value);
  // @@protoc_insertion_point(field_set:serum.ConsumeEventsRequest.num_accounts)
}

// string log_directory = 9;
inline void ConsumeEventsRequest::clear_log_directory() {
  log_directory_.ClearToEmpty();
}
inline const std::string& ConsumeEventsRequest::log_directory() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.log_directory)
  return _internal_log_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsumeEventsRequest::set_log_directory(ArgT0&& arg0, ArgT... args) {
 
 log_directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:serum.ConsumeEventsRequest.log_directory)
}
inline std::string* ConsumeEventsRequest::mutable_log_directory() {
  std::string* _s = _internal_mutable_log_directory();
  // @@protoc_insertion_point(field_mutable:serum.ConsumeEventsRequest.log_directory)
  return _s;
}
inline const std::string& ConsumeEventsRequest::_internal_log_directory() const {
  return log_directory_.Get();
}
inline void ConsumeEventsRequest::_internal_set_log_directory(const std::string& value) {
  
  log_directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsumeEventsRequest::_internal_mutable_log_directory() {
  
  return log_directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsumeEventsRequest::release_log_directory() {
  // @@protoc_insertion_point(field_release:serum.ConsumeEventsRequest.log_directory)
  return log_directory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsumeEventsRequest::set_allocated_log_directory(std::string* log_directory) {
  if (log_directory != nullptr) {
    
  } else {
    
  }
  log_directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log_directory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    log_directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:serum.ConsumeEventsRequest.log_directory)
}

// uint64 max_q_length = 10;
inline void ConsumeEventsRequest::clear_max_q_length() {
  max_q_length_ = uint64_t{0u};
}
inline uint64_t ConsumeEventsRequest::_internal_max_q_length() const {
  return max_q_length_;
}
inline uint64_t ConsumeEventsRequest::max_q_length() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.max_q_length)
  return _internal_max_q_length();
}
inline void ConsumeEventsRequest::_internal_set_max_q_length(uint64_t value) {
  
  max_q_length_ = value;
}
inline void ConsumeEventsRequest::set_max_q_length(uint64_t value) {
  _internal_set_max_q_length(value);
  // @@protoc_insertion_point(field_set:serum.ConsumeEventsRequest.max_q_length)
}

// uint64 max_wait_for_events_delay = 11;
inline void ConsumeEventsRequest::clear_max_wait_for_events_delay() {
  max_wait_for_events_delay_ = uint64_t{0u};
}
inline uint64_t ConsumeEventsRequest::_internal_max_wait_for_events_delay() const {
  return max_wait_for_events_delay_;
}
inline uint64_t ConsumeEventsRequest::max_wait_for_events_delay() const {
  // @@protoc_insertion_point(field_get:serum.ConsumeEventsRequest.max_wait_for_events_delay)
  return _internal_max_wait_for_events_delay();
}
inline void ConsumeEventsRequest::_internal_set_max_wait_for_events_delay(uint64_t value) {
  
  max_wait_for_events_delay_ = value;
}
inline void ConsumeEventsRequest::set_max_wait_for_events_delay(uint64_t value) {
  _internal_set_max_wait_for_events_delay(value);
  // @@protoc_insertion_point(field_set:serum.ConsumeEventsRequest.max_wait_for_events_delay)
}

// -------------------------------------------------------------------

// MatchOrdersRequest

// .basic.ProgramId dex_program_id = 1;
inline bool MatchOrdersRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool MatchOrdersRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& MatchOrdersRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& MatchOrdersRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.MatchOrdersRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void MatchOrdersRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MatchOrdersRequest.dex_program_id)
}
inline ::basic::ProgramId* MatchOrdersRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* MatchOrdersRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.MatchOrdersRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* MatchOrdersRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* MatchOrdersRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.MatchOrdersRequest.dex_program_id)
  return _msg;
}
inline void MatchOrdersRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.MatchOrdersRequest.dex_program_id)
}

// .basic.Keypair payer = 2;
inline bool MatchOrdersRequest::_internal_has_payer() const {
  return this != internal_default_instance() && payer_ != nullptr;
}
inline bool MatchOrdersRequest::has_payer() const {
  return _internal_has_payer();
}
inline const ::basic::Keypair& MatchOrdersRequest::_internal_payer() const {
  const ::basic::Keypair* p = payer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& MatchOrdersRequest::payer() const {
  // @@protoc_insertion_point(field_get:serum.MatchOrdersRequest.payer)
  return _internal_payer();
}
inline void MatchOrdersRequest::unsafe_arena_set_allocated_payer(
    ::basic::Keypair* payer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  payer_ = payer;
  if (payer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MatchOrdersRequest.payer)
}
inline ::basic::Keypair* MatchOrdersRequest::release_payer() {
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* MatchOrdersRequest::unsafe_arena_release_payer() {
  // @@protoc_insertion_point(field_release:serum.MatchOrdersRequest.payer)
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* MatchOrdersRequest::_internal_mutable_payer() {
  
  if (payer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    payer_ = p;
  }
  return payer_;
}
inline ::basic::Keypair* MatchOrdersRequest::mutable_payer() {
  ::basic::Keypair* _msg = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:serum.MatchOrdersRequest.payer)
  return _msg;
}
inline void MatchOrdersRequest::set_allocated_payer(::basic::Keypair* payer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  if (payer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer));
    if (message_arena != submessage_arena) {
      payer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payer, submessage_arena);
    }
    
  } else {
    
  }
  payer_ = payer;
  // @@protoc_insertion_point(field_set_allocated:serum.MatchOrdersRequest.payer)
}

// .serum.MarketState market = 3;
inline bool MatchOrdersRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool MatchOrdersRequest::has_market() const {
  return _internal_has_market();
}
inline void MatchOrdersRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& MatchOrdersRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& MatchOrdersRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.MatchOrdersRequest.market)
  return _internal_market();
}
inline void MatchOrdersRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MatchOrdersRequest.market)
}
inline ::serum::MarketState* MatchOrdersRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* MatchOrdersRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.MatchOrdersRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* MatchOrdersRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* MatchOrdersRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.MatchOrdersRequest.market)
  return _msg;
}
inline void MatchOrdersRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.MatchOrdersRequest.market)
}

// .basic.Pubkey coin_wallet = 4;
inline bool MatchOrdersRequest::_internal_has_coin_wallet() const {
  return this != internal_default_instance() && coin_wallet_ != nullptr;
}
inline bool MatchOrdersRequest::has_coin_wallet() const {
  return _internal_has_coin_wallet();
}
inline const ::basic::Pubkey& MatchOrdersRequest::_internal_coin_wallet() const {
  const ::basic::Pubkey* p = coin_wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MatchOrdersRequest::coin_wallet() const {
  // @@protoc_insertion_point(field_get:serum.MatchOrdersRequest.coin_wallet)
  return _internal_coin_wallet();
}
inline void MatchOrdersRequest::unsafe_arena_set_allocated_coin_wallet(
    ::basic::Pubkey* coin_wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet_);
  }
  coin_wallet_ = coin_wallet;
  if (coin_wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MatchOrdersRequest.coin_wallet)
}
inline ::basic::Pubkey* MatchOrdersRequest::release_coin_wallet() {
  
  ::basic::Pubkey* temp = coin_wallet_;
  coin_wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MatchOrdersRequest::unsafe_arena_release_coin_wallet() {
  // @@protoc_insertion_point(field_release:serum.MatchOrdersRequest.coin_wallet)
  
  ::basic::Pubkey* temp = coin_wallet_;
  coin_wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MatchOrdersRequest::_internal_mutable_coin_wallet() {
  
  if (coin_wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    coin_wallet_ = p;
  }
  return coin_wallet_;
}
inline ::basic::Pubkey* MatchOrdersRequest::mutable_coin_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_coin_wallet();
  // @@protoc_insertion_point(field_mutable:serum.MatchOrdersRequest.coin_wallet)
  return _msg;
}
inline void MatchOrdersRequest::set_allocated_coin_wallet(::basic::Pubkey* coin_wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet_);
  }
  if (coin_wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet));
    if (message_arena != submessage_arena) {
      coin_wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_wallet, submessage_arena);
    }
    
  } else {
    
  }
  coin_wallet_ = coin_wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.MatchOrdersRequest.coin_wallet)
}

// .basic.Pubkey pc_wallet = 5;
inline bool MatchOrdersRequest::_internal_has_pc_wallet() const {
  return this != internal_default_instance() && pc_wallet_ != nullptr;
}
inline bool MatchOrdersRequest::has_pc_wallet() const {
  return _internal_has_pc_wallet();
}
inline const ::basic::Pubkey& MatchOrdersRequest::_internal_pc_wallet() const {
  const ::basic::Pubkey* p = pc_wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MatchOrdersRequest::pc_wallet() const {
  // @@protoc_insertion_point(field_get:serum.MatchOrdersRequest.pc_wallet)
  return _internal_pc_wallet();
}
inline void MatchOrdersRequest::unsafe_arena_set_allocated_pc_wallet(
    ::basic::Pubkey* pc_wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet_);
  }
  pc_wallet_ = pc_wallet;
  if (pc_wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MatchOrdersRequest.pc_wallet)
}
inline ::basic::Pubkey* MatchOrdersRequest::release_pc_wallet() {
  
  ::basic::Pubkey* temp = pc_wallet_;
  pc_wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MatchOrdersRequest::unsafe_arena_release_pc_wallet() {
  // @@protoc_insertion_point(field_release:serum.MatchOrdersRequest.pc_wallet)
  
  ::basic::Pubkey* temp = pc_wallet_;
  pc_wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MatchOrdersRequest::_internal_mutable_pc_wallet() {
  
  if (pc_wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    pc_wallet_ = p;
  }
  return pc_wallet_;
}
inline ::basic::Pubkey* MatchOrdersRequest::mutable_pc_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_pc_wallet();
  // @@protoc_insertion_point(field_mutable:serum.MatchOrdersRequest.pc_wallet)
  return _msg;
}
inline void MatchOrdersRequest::set_allocated_pc_wallet(::basic::Pubkey* pc_wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet_);
  }
  if (pc_wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet));
    if (message_arena != submessage_arena) {
      pc_wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pc_wallet, submessage_arena);
    }
    
  } else {
    
  }
  pc_wallet_ = pc_wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.MatchOrdersRequest.pc_wallet)
}

// -------------------------------------------------------------------

// MonitorQueueRequest

// .basic.ProgramId dex_program_id = 1;
inline bool MonitorQueueRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool MonitorQueueRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& MonitorQueueRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& MonitorQueueRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.MonitorQueueRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void MonitorQueueRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MonitorQueueRequest.dex_program_id)
}
inline ::basic::ProgramId* MonitorQueueRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* MonitorQueueRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.MonitorQueueRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* MonitorQueueRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* MonitorQueueRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.MonitorQueueRequest.dex_program_id)
  return _msg;
}
inline void MonitorQueueRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.MonitorQueueRequest.dex_program_id)
}

// .serum.MarketState market = 2;
inline bool MonitorQueueRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool MonitorQueueRequest::has_market() const {
  return _internal_has_market();
}
inline void MonitorQueueRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& MonitorQueueRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& MonitorQueueRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.MonitorQueueRequest.market)
  return _internal_market();
}
inline void MonitorQueueRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MonitorQueueRequest.market)
}
inline ::serum::MarketState* MonitorQueueRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* MonitorQueueRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.MonitorQueueRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* MonitorQueueRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* MonitorQueueRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.MonitorQueueRequest.market)
  return _msg;
}
inline void MonitorQueueRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.MonitorQueueRequest.market)
}

// uint32 port = 3;
inline void MonitorQueueRequest::clear_port() {
  port_ = 0u;
}
inline uint32_t MonitorQueueRequest::_internal_port() const {
  return port_;
}
inline uint32_t MonitorQueueRequest::port() const {
  // @@protoc_insertion_point(field_get:serum.MonitorQueueRequest.port)
  return _internal_port();
}
inline void MonitorQueueRequest::_internal_set_port(uint32_t value) {
  
  port_ = value;
}
inline void MonitorQueueRequest::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:serum.MonitorQueueRequest.port)
}

// -------------------------------------------------------------------

// PrintEventQueue

// .basic.ProgramId dex_program_id = 1;
inline bool PrintEventQueue::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool PrintEventQueue::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& PrintEventQueue::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& PrintEventQueue::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.PrintEventQueue.dex_program_id)
  return _internal_dex_program_id();
}
inline void PrintEventQueue::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.PrintEventQueue.dex_program_id)
}
inline ::basic::ProgramId* PrintEventQueue::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* PrintEventQueue::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.PrintEventQueue.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* PrintEventQueue::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* PrintEventQueue::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.PrintEventQueue.dex_program_id)
  return _msg;
}
inline void PrintEventQueue::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.PrintEventQueue.dex_program_id)
}

// .basic.Pubkey market = 2;
inline bool PrintEventQueue::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool PrintEventQueue::has_market() const {
  return _internal_has_market();
}
inline const ::basic::Pubkey& PrintEventQueue::_internal_market() const {
  const ::basic::Pubkey* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& PrintEventQueue::market() const {
  // @@protoc_insertion_point(field_get:serum.PrintEventQueue.market)
  return _internal_market();
}
inline void PrintEventQueue::unsafe_arena_set_allocated_market(
    ::basic::Pubkey* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.PrintEventQueue.market)
}
inline ::basic::Pubkey* PrintEventQueue::release_market() {
  
  ::basic::Pubkey* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* PrintEventQueue::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.PrintEventQueue.market)
  
  ::basic::Pubkey* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* PrintEventQueue::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::basic::Pubkey* PrintEventQueue::mutable_market() {
  ::basic::Pubkey* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.PrintEventQueue.market)
  return _msg;
}
inline void PrintEventQueue::set_allocated_market(::basic::Pubkey* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.PrintEventQueue.market)
}

// -------------------------------------------------------------------

// WholeShebang

// .basic.Keypair payer = 1;
inline bool WholeShebang::_internal_has_payer() const {
  return this != internal_default_instance() && payer_ != nullptr;
}
inline bool WholeShebang::has_payer() const {
  return _internal_has_payer();
}
inline const ::basic::Keypair& WholeShebang::_internal_payer() const {
  const ::basic::Keypair* p = payer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& WholeShebang::payer() const {
  // @@protoc_insertion_point(field_get:serum.WholeShebang.payer)
  return _internal_payer();
}
inline void WholeShebang::unsafe_arena_set_allocated_payer(
    ::basic::Keypair* payer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  payer_ = payer;
  if (payer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.WholeShebang.payer)
}
inline ::basic::Keypair* WholeShebang::release_payer() {
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* WholeShebang::unsafe_arena_release_payer() {
  // @@protoc_insertion_point(field_release:serum.WholeShebang.payer)
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* WholeShebang::_internal_mutable_payer() {
  
  if (payer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    payer_ = p;
  }
  return payer_;
}
inline ::basic::Keypair* WholeShebang::mutable_payer() {
  ::basic::Keypair* _msg = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:serum.WholeShebang.payer)
  return _msg;
}
inline void WholeShebang::set_allocated_payer(::basic::Keypair* payer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  if (payer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer));
    if (message_arena != submessage_arena) {
      payer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payer, submessage_arena);
    }
    
  } else {
    
  }
  payer_ = payer;
  // @@protoc_insertion_point(field_set_allocated:serum.WholeShebang.payer)
}

// .basic.ProgramId dex_program_id = 2;
inline bool WholeShebang::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool WholeShebang::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& WholeShebang::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& WholeShebang::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.WholeShebang.dex_program_id)
  return _internal_dex_program_id();
}
inline void WholeShebang::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.WholeShebang.dex_program_id)
}
inline ::basic::ProgramId* WholeShebang::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* WholeShebang::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.WholeShebang.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* WholeShebang::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* WholeShebang::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.WholeShebang.dex_program_id)
  return _msg;
}
inline void WholeShebang::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.WholeShebang.dex_program_id)
}

// -------------------------------------------------------------------

// SettleFundsRequest

// .basic.Keypair payer = 1;
inline bool SettleFundsRequest::_internal_has_payer() const {
  return this != internal_default_instance() && payer_ != nullptr;
}
inline bool SettleFundsRequest::has_payer() const {
  return _internal_has_payer();
}
inline const ::basic::Keypair& SettleFundsRequest::_internal_payer() const {
  const ::basic::Keypair* p = payer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& SettleFundsRequest::payer() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.payer)
  return _internal_payer();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_payer(
    ::basic::Keypair* payer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  payer_ = payer;
  if (payer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.payer)
}
inline ::basic::Keypair* SettleFundsRequest::release_payer() {
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* SettleFundsRequest::unsafe_arena_release_payer() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.payer)
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* SettleFundsRequest::_internal_mutable_payer() {
  
  if (payer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    payer_ = p;
  }
  return payer_;
}
inline ::basic::Keypair* SettleFundsRequest::mutable_payer() {
  ::basic::Keypair* _msg = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.payer)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_payer(::basic::Keypair* payer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  if (payer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer));
    if (message_arena != submessage_arena) {
      payer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payer, submessage_arena);
    }
    
  } else {
    
  }
  payer_ = payer;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.payer)
}

// .basic.ProgramId dex_program_id = 2;
inline bool SettleFundsRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool SettleFundsRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& SettleFundsRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& SettleFundsRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.dex_program_id)
}
inline ::basic::ProgramId* SettleFundsRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* SettleFundsRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* SettleFundsRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* SettleFundsRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.dex_program_id)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.dex_program_id)
}

// .serum.MarketState market = 3;
inline bool SettleFundsRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool SettleFundsRequest::has_market() const {
  return _internal_has_market();
}
inline void SettleFundsRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
inline const ::serum::MarketState& SettleFundsRequest::_internal_market() const {
  const ::serum::MarketState* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::serum::MarketState&>(
      ::serum::_MarketState_default_instance_);
}
inline const ::serum::MarketState& SettleFundsRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.market)
  return _internal_market();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_market(
    ::serum::MarketState* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.market)
}
inline ::serum::MarketState* SettleFundsRequest::release_market() {
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serum::MarketState* SettleFundsRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.market)
  
  ::serum::MarketState* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::serum::MarketState* SettleFundsRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::serum::MarketState>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::serum::MarketState* SettleFundsRequest::mutable_market() {
  ::serum::MarketState* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.market)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_market(::serum::MarketState* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketState>::GetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.market)
}

// .basic.Pubkey orders = 4;
inline bool SettleFundsRequest::_internal_has_orders() const {
  return this != internal_default_instance() && orders_ != nullptr;
}
inline bool SettleFundsRequest::has_orders() const {
  return _internal_has_orders();
}
inline const ::basic::Pubkey& SettleFundsRequest::_internal_orders() const {
  const ::basic::Pubkey* p = orders_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& SettleFundsRequest::orders() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.orders)
  return _internal_orders();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_orders(
    ::basic::Pubkey* orders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  orders_ = orders;
  if (orders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.orders)
}
inline ::basic::Pubkey* SettleFundsRequest::release_orders() {
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* SettleFundsRequest::unsafe_arena_release_orders() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.orders)
  
  ::basic::Pubkey* temp = orders_;
  orders_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* SettleFundsRequest::_internal_mutable_orders() {
  
  if (orders_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    orders_ = p;
  }
  return orders_;
}
inline ::basic::Pubkey* SettleFundsRequest::mutable_orders() {
  ::basic::Pubkey* _msg = _internal_mutable_orders();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.orders)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_orders(::basic::Pubkey* orders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders_);
  }
  if (orders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orders));
    if (message_arena != submessage_arena) {
      orders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orders, submessage_arena);
    }
    
  } else {
    
  }
  orders_ = orders;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.orders)
}

// .basic.Pubkey coin_wallet = 5;
inline bool SettleFundsRequest::_internal_has_coin_wallet() const {
  return this != internal_default_instance() && coin_wallet_ != nullptr;
}
inline bool SettleFundsRequest::has_coin_wallet() const {
  return _internal_has_coin_wallet();
}
inline const ::basic::Pubkey& SettleFundsRequest::_internal_coin_wallet() const {
  const ::basic::Pubkey* p = coin_wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& SettleFundsRequest::coin_wallet() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.coin_wallet)
  return _internal_coin_wallet();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_coin_wallet(
    ::basic::Pubkey* coin_wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet_);
  }
  coin_wallet_ = coin_wallet;
  if (coin_wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.coin_wallet)
}
inline ::basic::Pubkey* SettleFundsRequest::release_coin_wallet() {
  
  ::basic::Pubkey* temp = coin_wallet_;
  coin_wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* SettleFundsRequest::unsafe_arena_release_coin_wallet() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.coin_wallet)
  
  ::basic::Pubkey* temp = coin_wallet_;
  coin_wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* SettleFundsRequest::_internal_mutable_coin_wallet() {
  
  if (coin_wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    coin_wallet_ = p;
  }
  return coin_wallet_;
}
inline ::basic::Pubkey* SettleFundsRequest::mutable_coin_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_coin_wallet();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.coin_wallet)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_coin_wallet(::basic::Pubkey* coin_wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet_);
  }
  if (coin_wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_wallet));
    if (message_arena != submessage_arena) {
      coin_wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_wallet, submessage_arena);
    }
    
  } else {
    
  }
  coin_wallet_ = coin_wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.coin_wallet)
}

// .basic.Pubkey pc_wallet = 6;
inline bool SettleFundsRequest::_internal_has_pc_wallet() const {
  return this != internal_default_instance() && pc_wallet_ != nullptr;
}
inline bool SettleFundsRequest::has_pc_wallet() const {
  return _internal_has_pc_wallet();
}
inline const ::basic::Pubkey& SettleFundsRequest::_internal_pc_wallet() const {
  const ::basic::Pubkey* p = pc_wallet_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& SettleFundsRequest::pc_wallet() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.pc_wallet)
  return _internal_pc_wallet();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_pc_wallet(
    ::basic::Pubkey* pc_wallet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet_);
  }
  pc_wallet_ = pc_wallet;
  if (pc_wallet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.pc_wallet)
}
inline ::basic::Pubkey* SettleFundsRequest::release_pc_wallet() {
  
  ::basic::Pubkey* temp = pc_wallet_;
  pc_wallet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* SettleFundsRequest::unsafe_arena_release_pc_wallet() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.pc_wallet)
  
  ::basic::Pubkey* temp = pc_wallet_;
  pc_wallet_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* SettleFundsRequest::_internal_mutable_pc_wallet() {
  
  if (pc_wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    pc_wallet_ = p;
  }
  return pc_wallet_;
}
inline ::basic::Pubkey* SettleFundsRequest::mutable_pc_wallet() {
  ::basic::Pubkey* _msg = _internal_mutable_pc_wallet();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.pc_wallet)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_pc_wallet(::basic::Pubkey* pc_wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet_);
  }
  if (pc_wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_wallet));
    if (message_arena != submessage_arena) {
      pc_wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pc_wallet, submessage_arena);
    }
    
  } else {
    
  }
  pc_wallet_ = pc_wallet;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.pc_wallet)
}

// .basic.Keypair signer = 7;
inline bool SettleFundsRequest::_internal_has_signer() const {
  return this != internal_default_instance() && signer_ != nullptr;
}
inline bool SettleFundsRequest::has_signer() const {
  return _internal_has_signer();
}
inline const ::basic::Keypair& SettleFundsRequest::_internal_signer() const {
  const ::basic::Keypair* p = signer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& SettleFundsRequest::signer() const {
  // @@protoc_insertion_point(field_get:serum.SettleFundsRequest.signer)
  return _internal_signer();
}
inline void SettleFundsRequest::unsafe_arena_set_allocated_signer(
    ::basic::Keypair* signer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signer_);
  }
  signer_ = signer;
  if (signer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.SettleFundsRequest.signer)
}
inline ::basic::Keypair* SettleFundsRequest::release_signer() {
  
  ::basic::Keypair* temp = signer_;
  signer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* SettleFundsRequest::unsafe_arena_release_signer() {
  // @@protoc_insertion_point(field_release:serum.SettleFundsRequest.signer)
  
  ::basic::Keypair* temp = signer_;
  signer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* SettleFundsRequest::_internal_mutable_signer() {
  
  if (signer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    signer_ = p;
  }
  return signer_;
}
inline ::basic::Keypair* SettleFundsRequest::mutable_signer() {
  ::basic::Keypair* _msg = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:serum.SettleFundsRequest.signer)
  return _msg;
}
inline void SettleFundsRequest::set_allocated_signer(::basic::Keypair* signer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signer_);
  }
  if (signer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signer));
    if (message_arena != submessage_arena) {
      signer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signer, submessage_arena);
    }
    
  } else {
    
  }
  signer_ = signer;
  // @@protoc_insertion_point(field_set_allocated:serum.SettleFundsRequest.signer)
}

// -------------------------------------------------------------------

// ListMarketRequest

// .basic.Keypair payer = 1;
inline bool ListMarketRequest::_internal_has_payer() const {
  return this != internal_default_instance() && payer_ != nullptr;
}
inline bool ListMarketRequest::has_payer() const {
  return _internal_has_payer();
}
inline const ::basic::Keypair& ListMarketRequest::_internal_payer() const {
  const ::basic::Keypair* p = payer_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Keypair&>(
      ::basic::_Keypair_default_instance_);
}
inline const ::basic::Keypair& ListMarketRequest::payer() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketRequest.payer)
  return _internal_payer();
}
inline void ListMarketRequest::unsafe_arena_set_allocated_payer(
    ::basic::Keypair* payer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  payer_ = payer;
  if (payer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ListMarketRequest.payer)
}
inline ::basic::Keypair* ListMarketRequest::release_payer() {
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Keypair* ListMarketRequest::unsafe_arena_release_payer() {
  // @@protoc_insertion_point(field_release:serum.ListMarketRequest.payer)
  
  ::basic::Keypair* temp = payer_;
  payer_ = nullptr;
  return temp;
}
inline ::basic::Keypair* ListMarketRequest::_internal_mutable_payer() {
  
  if (payer_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Keypair>(GetArenaForAllocation());
    payer_ = p;
  }
  return payer_;
}
inline ::basic::Keypair* ListMarketRequest::mutable_payer() {
  ::basic::Keypair* _msg = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:serum.ListMarketRequest.payer)
  return _msg;
}
inline void ListMarketRequest::set_allocated_payer(::basic::Keypair* payer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer_);
  }
  if (payer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payer));
    if (message_arena != submessage_arena) {
      payer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payer, submessage_arena);
    }
    
  } else {
    
  }
  payer_ = payer;
  // @@protoc_insertion_point(field_set_allocated:serum.ListMarketRequest.payer)
}

// .basic.ProgramId dex_program_id = 2;
inline bool ListMarketRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool ListMarketRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& ListMarketRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& ListMarketRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void ListMarketRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ListMarketRequest.dex_program_id)
}
inline ::basic::ProgramId* ListMarketRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* ListMarketRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.ListMarketRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* ListMarketRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* ListMarketRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.ListMarketRequest.dex_program_id)
  return _msg;
}
inline void ListMarketRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.ListMarketRequest.dex_program_id)
}

// .basic.Pubkey coin_mint = 3;
inline bool ListMarketRequest::_internal_has_coin_mint() const {
  return this != internal_default_instance() && coin_mint_ != nullptr;
}
inline bool ListMarketRequest::has_coin_mint() const {
  return _internal_has_coin_mint();
}
inline const ::basic::Pubkey& ListMarketRequest::_internal_coin_mint() const {
  const ::basic::Pubkey* p = coin_mint_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& ListMarketRequest::coin_mint() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketRequest.coin_mint)
  return _internal_coin_mint();
}
inline void ListMarketRequest::unsafe_arena_set_allocated_coin_mint(
    ::basic::Pubkey* coin_mint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_mint_);
  }
  coin_mint_ = coin_mint;
  if (coin_mint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ListMarketRequest.coin_mint)
}
inline ::basic::Pubkey* ListMarketRequest::release_coin_mint() {
  
  ::basic::Pubkey* temp = coin_mint_;
  coin_mint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* ListMarketRequest::unsafe_arena_release_coin_mint() {
  // @@protoc_insertion_point(field_release:serum.ListMarketRequest.coin_mint)
  
  ::basic::Pubkey* temp = coin_mint_;
  coin_mint_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* ListMarketRequest::_internal_mutable_coin_mint() {
  
  if (coin_mint_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    coin_mint_ = p;
  }
  return coin_mint_;
}
inline ::basic::Pubkey* ListMarketRequest::mutable_coin_mint() {
  ::basic::Pubkey* _msg = _internal_mutable_coin_mint();
  // @@protoc_insertion_point(field_mutable:serum.ListMarketRequest.coin_mint)
  return _msg;
}
inline void ListMarketRequest::set_allocated_coin_mint(::basic::Pubkey* coin_mint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_mint_);
  }
  if (coin_mint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_mint));
    if (message_arena != submessage_arena) {
      coin_mint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_mint, submessage_arena);
    }
    
  } else {
    
  }
  coin_mint_ = coin_mint;
  // @@protoc_insertion_point(field_set_allocated:serum.ListMarketRequest.coin_mint)
}

// .basic.Pubkey pc_mint = 4;
inline bool ListMarketRequest::_internal_has_pc_mint() const {
  return this != internal_default_instance() && pc_mint_ != nullptr;
}
inline bool ListMarketRequest::has_pc_mint() const {
  return _internal_has_pc_mint();
}
inline const ::basic::Pubkey& ListMarketRequest::_internal_pc_mint() const {
  const ::basic::Pubkey* p = pc_mint_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& ListMarketRequest::pc_mint() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketRequest.pc_mint)
  return _internal_pc_mint();
}
inline void ListMarketRequest::unsafe_arena_set_allocated_pc_mint(
    ::basic::Pubkey* pc_mint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_mint_);
  }
  pc_mint_ = pc_mint;
  if (pc_mint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.ListMarketRequest.pc_mint)
}
inline ::basic::Pubkey* ListMarketRequest::release_pc_mint() {
  
  ::basic::Pubkey* temp = pc_mint_;
  pc_mint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* ListMarketRequest::unsafe_arena_release_pc_mint() {
  // @@protoc_insertion_point(field_release:serum.ListMarketRequest.pc_mint)
  
  ::basic::Pubkey* temp = pc_mint_;
  pc_mint_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* ListMarketRequest::_internal_mutable_pc_mint() {
  
  if (pc_mint_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    pc_mint_ = p;
  }
  return pc_mint_;
}
inline ::basic::Pubkey* ListMarketRequest::mutable_pc_mint() {
  ::basic::Pubkey* _msg = _internal_mutable_pc_mint();
  // @@protoc_insertion_point(field_mutable:serum.ListMarketRequest.pc_mint)
  return _msg;
}
inline void ListMarketRequest::set_allocated_pc_mint(::basic::Pubkey* pc_mint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_mint_);
  }
  if (pc_mint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pc_mint));
    if (message_arena != submessage_arena) {
      pc_mint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pc_mint, submessage_arena);
    }
    
  } else {
    
  }
  pc_mint_ = pc_mint;
  // @@protoc_insertion_point(field_set_allocated:serum.ListMarketRequest.pc_mint)
}

// uint64 coin_lot_size = 5;
inline void ListMarketRequest::clear_coin_lot_size() {
  coin_lot_size_ = uint64_t{0u};
}
inline uint64_t ListMarketRequest::_internal_coin_lot_size() const {
  return coin_lot_size_;
}
inline uint64_t ListMarketRequest::coin_lot_size() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketRequest.coin_lot_size)
  return _internal_coin_lot_size();
}
inline void ListMarketRequest::_internal_set_coin_lot_size(uint64_t value) {
  
  coin_lot_size_ = value;
}
inline void ListMarketRequest::set_coin_lot_size(uint64_t value) {
  _internal_set_coin_lot_size(value);
  // @@protoc_insertion_point(field_set:serum.ListMarketRequest.coin_lot_size)
}

// uint64 pc_lot_size = 6;
inline void ListMarketRequest::clear_pc_lot_size() {
  pc_lot_size_ = uint64_t{0u};
}
inline uint64_t ListMarketRequest::_internal_pc_lot_size() const {
  return pc_lot_size_;
}
inline uint64_t ListMarketRequest::pc_lot_size() const {
  // @@protoc_insertion_point(field_get:serum.ListMarketRequest.pc_lot_size)
  return _internal_pc_lot_size();
}
inline void ListMarketRequest::_internal_set_pc_lot_size(uint64_t value) {
  
  pc_lot_size_ = value;
}
inline void ListMarketRequest::set_pc_lot_size(uint64_t value) {
  _internal_set_pc_lot_size(value);
  // @@protoc_insertion_point(field_set:serum.ListMarketRequest.pc_lot_size)
}

// -------------------------------------------------------------------

// InitializeTokenAccount

// .basic.Pubkey mint = 1;
inline bool InitializeTokenAccount::_internal_has_mint() const {
  return this != internal_default_instance() && mint_ != nullptr;
}
inline bool InitializeTokenAccount::has_mint() const {
  return _internal_has_mint();
}
inline const ::basic::Pubkey& InitializeTokenAccount::_internal_mint() const {
  const ::basic::Pubkey* p = mint_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& InitializeTokenAccount::mint() const {
  // @@protoc_insertion_point(field_get:serum.InitializeTokenAccount.mint)
  return _internal_mint();
}
inline void InitializeTokenAccount::unsafe_arena_set_allocated_mint(
    ::basic::Pubkey* mint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mint_);
  }
  mint_ = mint;
  if (mint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.InitializeTokenAccount.mint)
}
inline ::basic::Pubkey* InitializeTokenAccount::release_mint() {
  
  ::basic::Pubkey* temp = mint_;
  mint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* InitializeTokenAccount::unsafe_arena_release_mint() {
  // @@protoc_insertion_point(field_release:serum.InitializeTokenAccount.mint)
  
  ::basic::Pubkey* temp = mint_;
  mint_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* InitializeTokenAccount::_internal_mutable_mint() {
  
  if (mint_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    mint_ = p;
  }
  return mint_;
}
inline ::basic::Pubkey* InitializeTokenAccount::mutable_mint() {
  ::basic::Pubkey* _msg = _internal_mutable_mint();
  // @@protoc_insertion_point(field_mutable:serum.InitializeTokenAccount.mint)
  return _msg;
}
inline void InitializeTokenAccount::set_allocated_mint(::basic::Pubkey* mint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mint_);
  }
  if (mint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mint));
    if (message_arena != submessage_arena) {
      mint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mint, submessage_arena);
    }
    
  } else {
    
  }
  mint_ = mint;
  // @@protoc_insertion_point(field_set_allocated:serum.InitializeTokenAccount.mint)
}

// .basic.Pubkey owner_account = 2;
inline bool InitializeTokenAccount::_internal_has_owner_account() const {
  return this != internal_default_instance() && owner_account_ != nullptr;
}
inline bool InitializeTokenAccount::has_owner_account() const {
  return _internal_has_owner_account();
}
inline const ::basic::Pubkey& InitializeTokenAccount::_internal_owner_account() const {
  const ::basic::Pubkey* p = owner_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& InitializeTokenAccount::owner_account() const {
  // @@protoc_insertion_point(field_get:serum.InitializeTokenAccount.owner_account)
  return _internal_owner_account();
}
inline void InitializeTokenAccount::unsafe_arena_set_allocated_owner_account(
    ::basic::Pubkey* owner_account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_account_);
  }
  owner_account_ = owner_account;
  if (owner_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.InitializeTokenAccount.owner_account)
}
inline ::basic::Pubkey* InitializeTokenAccount::release_owner_account() {
  
  ::basic::Pubkey* temp = owner_account_;
  owner_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* InitializeTokenAccount::unsafe_arena_release_owner_account() {
  // @@protoc_insertion_point(field_release:serum.InitializeTokenAccount.owner_account)
  
  ::basic::Pubkey* temp = owner_account_;
  owner_account_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* InitializeTokenAccount::_internal_mutable_owner_account() {
  
  if (owner_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    owner_account_ = p;
  }
  return owner_account_;
}
inline ::basic::Pubkey* InitializeTokenAccount::mutable_owner_account() {
  ::basic::Pubkey* _msg = _internal_mutable_owner_account();
  // @@protoc_insertion_point(field_mutable:serum.InitializeTokenAccount.owner_account)
  return _msg;
}
inline void InitializeTokenAccount::set_allocated_owner_account(::basic::Pubkey* owner_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_account_);
  }
  if (owner_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_account));
    if (message_arena != submessage_arena) {
      owner_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_account, submessage_arena);
    }
    
  } else {
    
  }
  owner_account_ = owner_account;
  // @@protoc_insertion_point(field_set_allocated:serum.InitializeTokenAccount.owner_account)
}

// -------------------------------------------------------------------

// MarketRequest

// .basic.ProgramId dex_program_id = 1;
inline bool MarketRequest::_internal_has_dex_program_id() const {
  return this != internal_default_instance() && dex_program_id_ != nullptr;
}
inline bool MarketRequest::has_dex_program_id() const {
  return _internal_has_dex_program_id();
}
inline const ::basic::ProgramId& MarketRequest::_internal_dex_program_id() const {
  const ::basic::ProgramId* p = dex_program_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::ProgramId&>(
      ::basic::_ProgramId_default_instance_);
}
inline const ::basic::ProgramId& MarketRequest::dex_program_id() const {
  // @@protoc_insertion_point(field_get:serum.MarketRequest.dex_program_id)
  return _internal_dex_program_id();
}
inline void MarketRequest::unsafe_arena_set_allocated_dex_program_id(
    ::basic::ProgramId* dex_program_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  dex_program_id_ = dex_program_id;
  if (dex_program_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketRequest.dex_program_id)
}
inline ::basic::ProgramId* MarketRequest::release_dex_program_id() {
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::ProgramId* MarketRequest::unsafe_arena_release_dex_program_id() {
  // @@protoc_insertion_point(field_release:serum.MarketRequest.dex_program_id)
  
  ::basic::ProgramId* temp = dex_program_id_;
  dex_program_id_ = nullptr;
  return temp;
}
inline ::basic::ProgramId* MarketRequest::_internal_mutable_dex_program_id() {
  
  if (dex_program_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::ProgramId>(GetArenaForAllocation());
    dex_program_id_ = p;
  }
  return dex_program_id_;
}
inline ::basic::ProgramId* MarketRequest::mutable_dex_program_id() {
  ::basic::ProgramId* _msg = _internal_mutable_dex_program_id();
  // @@protoc_insertion_point(field_mutable:serum.MarketRequest.dex_program_id)
  return _msg;
}
inline void MarketRequest::set_allocated_dex_program_id(::basic::ProgramId* dex_program_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id_);
  }
  if (dex_program_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dex_program_id));
    if (message_arena != submessage_arena) {
      dex_program_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dex_program_id, submessage_arena);
    }
    
  } else {
    
  }
  dex_program_id_ = dex_program_id;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketRequest.dex_program_id)
}

// .basic.Pubkey market = 2;
inline bool MarketRequest::_internal_has_market() const {
  return this != internal_default_instance() && market_ != nullptr;
}
inline bool MarketRequest::has_market() const {
  return _internal_has_market();
}
inline const ::basic::Pubkey& MarketRequest::_internal_market() const {
  const ::basic::Pubkey* p = market_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& MarketRequest::market() const {
  // @@protoc_insertion_point(field_get:serum.MarketRequest.market)
  return _internal_market();
}
inline void MarketRequest::unsafe_arena_set_allocated_market(
    ::basic::Pubkey* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  market_ = market;
  if (market) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serum.MarketRequest.market)
}
inline ::basic::Pubkey* MarketRequest::release_market() {
  
  ::basic::Pubkey* temp = market_;
  market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* MarketRequest::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:serum.MarketRequest.market)
  
  ::basic::Pubkey* temp = market_;
  market_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* MarketRequest::_internal_mutable_market() {
  
  if (market_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    market_ = p;
  }
  return market_;
}
inline ::basic::Pubkey* MarketRequest::mutable_market() {
  ::basic::Pubkey* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:serum.MarketRequest.market)
  return _msg;
}
inline void MarketRequest::set_allocated_market(::basic::Pubkey* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:serum.MarketRequest.market)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace serum

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::serum::SelfTradeBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serum::SelfTradeBehavior>() {
  return ::serum::SelfTradeBehavior_descriptor();
}
template <> struct is_proto_enum< ::serum::OrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serum::OrderType>() {
  return ::serum::OrderType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fserum_2eproto

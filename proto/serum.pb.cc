// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/serum.proto

#include "proto/serum.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace serum {
constexpr MarketState::MarketState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct MarketStateDefaultTypeInternal {
  constexpr MarketStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MarketStateDefaultTypeInternal() {}
  union {
    MarketState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MarketStateDefaultTypeInternal _MarketState_default_instance_;
constexpr InitOpenOrderRequest::InitOpenOrderRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , owner_(nullptr)
  , market_(nullptr)
  , orders_(nullptr){}
struct InitOpenOrderRequestDefaultTypeInternal {
  constexpr InitOpenOrderRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitOpenOrderRequestDefaultTypeInternal() {}
  union {
    InitOpenOrderRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitOpenOrderRequestDefaultTypeInternal _InitOpenOrderRequest_default_instance_;
constexpr CloseOpenOrderRequest::CloseOpenOrderRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , owner_(nullptr)
  , market_(nullptr)
  , orders_(nullptr){}
struct CloseOpenOrderRequestDefaultTypeInternal {
  constexpr CloseOpenOrderRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CloseOpenOrderRequestDefaultTypeInternal() {}
  union {
    CloseOpenOrderRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CloseOpenOrderRequestDefaultTypeInternal _CloseOpenOrderRequest_default_instance_;
constexpr CancelOrderRequest::CancelOrderRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , owner_(nullptr)
  , market_(nullptr)
  , orders_(nullptr)
  , id_(uint64_t{0u}){}
struct CancelOrderRequestDefaultTypeInternal {
  constexpr CancelOrderRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CancelOrderRequestDefaultTypeInternal() {}
  union {
    CancelOrderRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CancelOrderRequestDefaultTypeInternal _CancelOrderRequest_default_instance_;
constexpr ListMarketResponse::ListMarketResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : market_pubkeys_(nullptr)
  , tx_(nullptr){}
struct ListMarketResponseDefaultTypeInternal {
  constexpr ListMarketResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListMarketResponseDefaultTypeInternal() {}
  union {
    ListMarketResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListMarketResponseDefaultTypeInternal _ListMarketResponse_default_instance_;
constexpr Order::Order(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , payer_(nullptr)
  , wallet_(nullptr)
  , market_(nullptr)
  , orders_(nullptr)
  , _oneof_case_{}{}
struct OrderDefaultTypeInternal {
  constexpr OrderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OrderDefaultTypeInternal() {}
  union {
    Order _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OrderDefaultTypeInternal _Order_default_instance_;
constexpr OrderStatus::OrderStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_with_slot_(nullptr){}
struct OrderStatusDefaultTypeInternal {
  constexpr OrderStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OrderStatusDefaultTypeInternal() {}
  union {
    OrderStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OrderStatusDefaultTypeInternal _OrderStatus_default_instance_;
constexpr NewOrderInstructionV3::NewOrderInstructionV3(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : limit_price_(uint64_t{0u})
  , max_coin_qty_(uint64_t{0u})
  , side_(false)
  , self_trade_behavior_(0)

  , max_native_pc_qty_including_fees_(uint64_t{0u})
  , client_order_id_(uint64_t{0u})
  , order_type_(0)

  , limit_(0u){}
struct NewOrderInstructionV3DefaultTypeInternal {
  constexpr NewOrderInstructionV3DefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NewOrderInstructionV3DefaultTypeInternal() {}
  union {
    NewOrderInstructionV3 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NewOrderInstructionV3DefaultTypeInternal _NewOrderInstructionV3_default_instance_;
constexpr Event::Event(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct EventDefaultTypeInternal {
  constexpr EventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EventDefaultTypeInternal _Event_default_instance_;
constexpr Bid::Bid(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BidDefaultTypeInternal {
  constexpr BidDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BidDefaultTypeInternal() {}
  union {
    Bid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BidDefaultTypeInternal _Bid_default_instance_;
constexpr Ask::Ask(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AskDefaultTypeInternal {
  constexpr AskDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AskDefaultTypeInternal() {}
  union {
    Ask _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AskDefaultTypeInternal _Ask_default_instance_;
constexpr ConsumeEventUpdate::ConsumeEventUpdate(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , crank_count_(int64_t{0}){}
struct ConsumeEventUpdateDefaultTypeInternal {
  constexpr ConsumeEventUpdateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConsumeEventUpdateDefaultTypeInternal() {}
  union {
    ConsumeEventUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConsumeEventUpdateDefaultTypeInternal _ConsumeEventUpdate_default_instance_;
constexpr MarketPubkeys::MarketPubkeys(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : market_(nullptr)
  , req_q_(nullptr)
  , event_q_(nullptr)
  , bids_(nullptr)
  , asks_(nullptr)
  , coin_vault_(nullptr)
  , pc_vault_(nullptr)
  , vault_signer_key_(nullptr){}
struct MarketPubkeysDefaultTypeInternal {
  constexpr MarketPubkeysDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MarketPubkeysDefaultTypeInternal() {}
  union {
    MarketPubkeys _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MarketPubkeysDefaultTypeInternal _MarketPubkeys_default_instance_;
constexpr ConsumeEventsRequest::ConsumeEventsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : log_directory_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , dex_program_id_(nullptr)
  , payer_(nullptr)
  , market_(nullptr)
  , coin_wallet_(nullptr)
  , pc_wallet_(nullptr)
  , num_workers_(uint64_t{0u})
  , events_per_worker_(uint64_t{0u})
  , num_accounts_(uint64_t{0u})
  , max_q_length_(uint64_t{0u})
  , max_wait_for_events_delay_(uint64_t{0u}){}
struct ConsumeEventsRequestDefaultTypeInternal {
  constexpr ConsumeEventsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConsumeEventsRequestDefaultTypeInternal() {}
  union {
    ConsumeEventsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConsumeEventsRequestDefaultTypeInternal _ConsumeEventsRequest_default_instance_;
constexpr MatchOrdersRequest::MatchOrdersRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , payer_(nullptr)
  , market_(nullptr)
  , coin_wallet_(nullptr)
  , pc_wallet_(nullptr){}
struct MatchOrdersRequestDefaultTypeInternal {
  constexpr MatchOrdersRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MatchOrdersRequestDefaultTypeInternal() {}
  union {
    MatchOrdersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MatchOrdersRequestDefaultTypeInternal _MatchOrdersRequest_default_instance_;
constexpr MonitorQueueRequest::MonitorQueueRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , market_(nullptr)
  , port_(0u){}
struct MonitorQueueRequestDefaultTypeInternal {
  constexpr MonitorQueueRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MonitorQueueRequestDefaultTypeInternal() {}
  union {
    MonitorQueueRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MonitorQueueRequestDefaultTypeInternal _MonitorQueueRequest_default_instance_;
constexpr PrintEventQueue::PrintEventQueue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , market_(nullptr){}
struct PrintEventQueueDefaultTypeInternal {
  constexpr PrintEventQueueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PrintEventQueueDefaultTypeInternal() {}
  union {
    PrintEventQueue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PrintEventQueueDefaultTypeInternal _PrintEventQueue_default_instance_;
constexpr WholeShebang::WholeShebang(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : payer_(nullptr)
  , dex_program_id_(nullptr){}
struct WholeShebangDefaultTypeInternal {
  constexpr WholeShebangDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WholeShebangDefaultTypeInternal() {}
  union {
    WholeShebang _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WholeShebangDefaultTypeInternal _WholeShebang_default_instance_;
constexpr SettleFundsRequest::SettleFundsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : payer_(nullptr)
  , dex_program_id_(nullptr)
  , market_(nullptr)
  , orders_(nullptr)
  , coin_wallet_(nullptr)
  , pc_wallet_(nullptr)
  , signer_(nullptr){}
struct SettleFundsRequestDefaultTypeInternal {
  constexpr SettleFundsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SettleFundsRequestDefaultTypeInternal() {}
  union {
    SettleFundsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SettleFundsRequestDefaultTypeInternal _SettleFundsRequest_default_instance_;
constexpr ListMarketRequest::ListMarketRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : payer_(nullptr)
  , dex_program_id_(nullptr)
  , coin_mint_(nullptr)
  , pc_mint_(nullptr)
  , coin_lot_size_(uint64_t{0u})
  , pc_lot_size_(uint64_t{0u}){}
struct ListMarketRequestDefaultTypeInternal {
  constexpr ListMarketRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListMarketRequestDefaultTypeInternal() {}
  union {
    ListMarketRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListMarketRequestDefaultTypeInternal _ListMarketRequest_default_instance_;
constexpr InitializeTokenAccount::InitializeTokenAccount(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mint_(nullptr)
  , owner_account_(nullptr){}
struct InitializeTokenAccountDefaultTypeInternal {
  constexpr InitializeTokenAccountDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitializeTokenAccountDefaultTypeInternal() {}
  union {
    InitializeTokenAccount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitializeTokenAccountDefaultTypeInternal _InitializeTokenAccount_default_instance_;
constexpr MarketRequest::MarketRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dex_program_id_(nullptr)
  , market_(nullptr){}
struct MarketRequestDefaultTypeInternal {
  constexpr MarketRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MarketRequestDefaultTypeInternal() {}
  union {
    MarketRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MarketRequestDefaultTypeInternal _MarketRequest_default_instance_;
}  // namespace serum
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_proto_2fserum_2eproto[22];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_proto_2fserum_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_proto_2fserum_2eproto = nullptr;

const uint32_t TableStruct_proto_2fserum_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::MarketState, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serum::MarketState, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serum::MarketState, market_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::InitOpenOrderRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::InitOpenOrderRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::InitOpenOrderRequest, owner_),
  PROTOBUF_FIELD_OFFSET(::serum::InitOpenOrderRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::InitOpenOrderRequest, orders_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::CloseOpenOrderRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::CloseOpenOrderRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::CloseOpenOrderRequest, owner_),
  PROTOBUF_FIELD_OFFSET(::serum::CloseOpenOrderRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::CloseOpenOrderRequest, orders_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::CancelOrderRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::CancelOrderRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::CancelOrderRequest, owner_),
  PROTOBUF_FIELD_OFFSET(::serum::CancelOrderRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::CancelOrderRequest, orders_),
  PROTOBUF_FIELD_OFFSET(::serum::CancelOrderRequest, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketResponse, market_pubkeys_),
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketResponse, tx_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::Order, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serum::Order, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serum::Order, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::Order, payer_),
  PROTOBUF_FIELD_OFFSET(::serum::Order, wallet_),
  PROTOBUF_FIELD_OFFSET(::serum::Order, market_),
  PROTOBUF_FIELD_OFFSET(::serum::Order, orders_),
  PROTOBUF_FIELD_OFFSET(::serum::Order, order_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::OrderStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::OrderStatus, status_with_slot_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, side_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, limit_price_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, max_coin_qty_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, max_native_pc_qty_including_fees_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, self_trade_behavior_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, order_type_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, client_order_id_),
  PROTOBUF_FIELD_OFFSET(::serum::NewOrderInstructionV3, limit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::Event, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::serum::Event, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::serum::Event, event_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::Bid, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::Ask, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventUpdate, crank_count_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventUpdate, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, market_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, req_q_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, event_q_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, bids_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, asks_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, coin_vault_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, pc_vault_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketPubkeys, vault_signer_key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, payer_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, coin_wallet_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, pc_wallet_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, num_workers_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, events_per_worker_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, num_accounts_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, log_directory_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, max_q_length_),
  PROTOBUF_FIELD_OFFSET(::serum::ConsumeEventsRequest, max_wait_for_events_delay_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::MatchOrdersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::MatchOrdersRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::MatchOrdersRequest, payer_),
  PROTOBUF_FIELD_OFFSET(::serum::MatchOrdersRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::MatchOrdersRequest, coin_wallet_),
  PROTOBUF_FIELD_OFFSET(::serum::MatchOrdersRequest, pc_wallet_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::MonitorQueueRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::MonitorQueueRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::MonitorQueueRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::MonitorQueueRequest, port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::PrintEventQueue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::PrintEventQueue, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::PrintEventQueue, market_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::WholeShebang, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::WholeShebang, payer_),
  PROTOBUF_FIELD_OFFSET(::serum::WholeShebang, dex_program_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, payer_),
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, market_),
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, orders_),
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, coin_wallet_),
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, pc_wallet_),
  PROTOBUF_FIELD_OFFSET(::serum::SettleFundsRequest, signer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, payer_),
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, coin_mint_),
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, pc_mint_),
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, coin_lot_size_),
  PROTOBUF_FIELD_OFFSET(::serum::ListMarketRequest, pc_lot_size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::InitializeTokenAccount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::InitializeTokenAccount, mint_),
  PROTOBUF_FIELD_OFFSET(::serum::InitializeTokenAccount, owner_account_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::serum::MarketRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::serum::MarketRequest, dex_program_id_),
  PROTOBUF_FIELD_OFFSET(::serum::MarketRequest, market_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::serum::MarketState)},
  { 9, -1, -1, sizeof(::serum::InitOpenOrderRequest)},
  { 19, -1, -1, sizeof(::serum::CloseOpenOrderRequest)},
  { 29, -1, -1, sizeof(::serum::CancelOrderRequest)},
  { 40, -1, -1, sizeof(::serum::ListMarketResponse)},
  { 48, -1, -1, sizeof(::serum::Order)},
  { 61, -1, -1, sizeof(::serum::OrderStatus)},
  { 68, -1, -1, sizeof(::serum::NewOrderInstructionV3)},
  { 82, -1, -1, sizeof(::serum::Event)},
  { 91, -1, -1, sizeof(::serum::Bid)},
  { 97, -1, -1, sizeof(::serum::Ask)},
  { 103, -1, -1, sizeof(::serum::ConsumeEventUpdate)},
  { 111, -1, -1, sizeof(::serum::MarketPubkeys)},
  { 125, -1, -1, sizeof(::serum::ConsumeEventsRequest)},
  { 142, -1, -1, sizeof(::serum::MatchOrdersRequest)},
  { 153, -1, -1, sizeof(::serum::MonitorQueueRequest)},
  { 162, -1, -1, sizeof(::serum::PrintEventQueue)},
  { 170, -1, -1, sizeof(::serum::WholeShebang)},
  { 178, -1, -1, sizeof(::serum::SettleFundsRequest)},
  { 191, -1, -1, sizeof(::serum::ListMarketRequest)},
  { 203, -1, -1, sizeof(::serum::InitializeTokenAccount)},
  { 211, -1, -1, sizeof(::serum::MarketRequest)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_MarketState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_InitOpenOrderRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_CloseOpenOrderRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_CancelOrderRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_ListMarketResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_Order_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_OrderStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_NewOrderInstructionV3_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_Event_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_Bid_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_Ask_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_ConsumeEventUpdate_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_MarketPubkeys_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_ConsumeEventsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_MatchOrdersRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_MonitorQueueRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_PrintEventQueue_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_WholeShebang_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_SettleFundsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_ListMarketRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_InitializeTokenAccount_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::serum::_MarketRequest_default_instance_),
};

const char descriptor_table_protodef_proto_2fserum_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021proto/serum.proto\022\005serum\032\021proto/basic."
  "proto\"[\n\013MarketState\022\033\n\002id\030\001 \001(\0132\r.basic"
  ".PubkeyH\000\022%\n\005state\030\002 \001(\0132\024.serum.MarketP"
  "ubkeysH\000B\010\n\006market\"\242\001\n\024InitOpenOrderRequ"
  "est\022(\n\016dex_program_id\030\001 \001(\0132\020.basic.Prog"
  "ramId\022\035\n\005owner\030\002 \001(\0132\016.basic.Keypair\022\"\n\006"
  "market\030\003 \001(\0132\022.serum.MarketState\022\035\n\006orde"
  "rs\030\004 \001(\0132\r.basic.Pubkey\"\243\001\n\025CloseOpenOrd"
  "erRequest\022(\n\016dex_program_id\030\001 \001(\0132\020.basi"
  "c.ProgramId\022\035\n\005owner\030\002 \001(\0132\016.basic.Keypa"
  "ir\022\"\n\006market\030\003 \001(\0132\022.serum.MarketState\022\035"
  "\n\006orders\030\004 \001(\0132\r.basic.Pubkey\"\254\001\n\022Cancel"
  "OrderRequest\022(\n\016dex_program_id\030\001 \001(\0132\020.b"
  "asic.ProgramId\022\035\n\005owner\030\002 \001(\0132\016.basic.Ke"
  "ypair\022\"\n\006market\030\003 \001(\0132\022.serum.MarketStat"
  "e\022\035\n\006orders\030\004 \001(\0132\r.basic.Pubkey\022\n\n\002id\030\005"
  " \001(\004\"_\n\022ListMarketResponse\022,\n\016market_pub"
  "keys\030\001 \001(\0132\024.serum.MarketPubkeys\022\033\n\002tx\030\002"
  " \001(\0132\017.basic.SignedTx\"\347\001\n\005Order\022*\n\002v3\030\001 "
  "\001(\0132\034.serum.NewOrderInstructionV3H\000\022(\n\016d"
  "ex_program_id\030\002 \001(\0132\020.basic.ProgramId\022\035\n"
  "\005payer\030\003 \001(\0132\016.basic.Keypair\022\035\n\006wallet\030\004"
  " \001(\0132\r.basic.Pubkey\022\"\n\006market\030\005 \001(\0132\022.se"
  "rum.MarketState\022\035\n\006orders\030\006 \001(\0132\r.basic."
  "PubkeyB\007\n\005order\"@\n\013OrderStatus\0221\n\020status"
  "_with_slot\030\001 \001(\0132\027.basic.TxStatusWithSlo"
  "t\"\377\001\n\025NewOrderInstructionV3\022\014\n\004side\030\001 \001("
  "\010\022\023\n\013limit_price\030\002 \001(\004\022\024\n\014max_coin_qty\030\003"
  " \001(\004\022(\n max_native_pc_qty_including_fees"
  "\030\004 \001(\004\0225\n\023self_trade_behavior\030\005 \001(\0162\030.se"
  "rum.SelfTradeBehavior\022$\n\norder_type\030\006 \001("
  "\0162\020.serum.OrderType\022\027\n\017client_order_id\030\007"
  " \001(\004\022\r\n\005limit\030\010 \001(\r\"F\n\005Event\022\031\n\003bid\030\001 \001("
  "\0132\n.serum.BidH\000\022\031\n\003ask\030\002 \001(\0132\n.serum.Ask"
  "H\000B\007\n\005event\"\005\n\003Bid\"\005\n\003Ask\"9\n\022ConsumeEven"
  "tUpdate\022\023\n\013crank_count\030\001 \001(\003\022\016\n\006status\030\002"
  " \001(\t\"\223\002\n\rMarketPubkeys\022\035\n\006market\030\001 \001(\0132\r"
  ".basic.Pubkey\022\034\n\005req_q\030\002 \001(\0132\r.basic.Pub"
  "key\022\036\n\007event_q\030\003 \001(\0132\r.basic.Pubkey\022\033\n\004b"
  "ids\030\004 \001(\0132\r.basic.Pubkey\022\033\n\004asks\030\005 \001(\0132\r"
  ".basic.Pubkey\022!\n\ncoin_vault\030\006 \001(\0132\r.basi"
  "c.Pubkey\022\037\n\010pc_vault\030\007 \001(\0132\r.basic.Pubke"
  "y\022\'\n\020vault_signer_key\030\010 \001(\0132\r.basic.Pubk"
  "ey\"\337\002\n\024ConsumeEventsRequest\022(\n\016dex_progr"
  "am_id\030\001 \001(\0132\020.basic.ProgramId\022\035\n\005payer\030\002"
  " \001(\0132\016.basic.Keypair\022\"\n\006market\030\003 \001(\0132\022.s"
  "erum.MarketState\022\"\n\013coin_wallet\030\004 \001(\0132\r."
  "basic.Pubkey\022 \n\tpc_wallet\030\005 \001(\0132\r.basic."
  "Pubkey\022\023\n\013num_workers\030\006 \001(\004\022\031\n\021events_pe"
  "r_worker\030\007 \001(\004\022\024\n\014num_accounts\030\010 \001(\004\022\025\n\r"
  "log_directory\030\t \001(\t\022\024\n\014max_q_length\030\n \001("
  "\004\022!\n\031max_wait_for_events_delay\030\013 \001(\004\"\307\001\n"
  "\022MatchOrdersRequest\022(\n\016dex_program_id\030\001 "
  "\001(\0132\020.basic.ProgramId\022\035\n\005payer\030\002 \001(\0132\016.b"
  "asic.Keypair\022\"\n\006market\030\003 \001(\0132\022.serum.Mar"
  "ketState\022\"\n\013coin_wallet\030\004 \001(\0132\r.basic.Pu"
  "bkey\022 \n\tpc_wallet\030\005 \001(\0132\r.basic.Pubkey\"q"
  "\n\023MonitorQueueRequest\022(\n\016dex_program_id\030"
  "\001 \001(\0132\020.basic.ProgramId\022\"\n\006market\030\002 \001(\0132"
  "\022.serum.MarketState\022\014\n\004port\030\003 \001(\r\"Z\n\017Pri"
  "ntEventQueue\022(\n\016dex_program_id\030\001 \001(\0132\020.b"
  "asic.ProgramId\022\035\n\006market\030\002 \001(\0132\r.basic.P"
  "ubkey\"W\n\014WholeShebang\022\035\n\005payer\030\001 \001(\0132\016.b"
  "asic.Keypair\022(\n\016dex_program_id\030\002 \001(\0132\020.b"
  "asic.ProgramId\"\206\002\n\022SettleFundsRequest\022\035\n"
  "\005payer\030\001 \001(\0132\016.basic.Keypair\022(\n\016dex_prog"
  "ram_id\030\002 \001(\0132\020.basic.ProgramId\022\"\n\006market"
  "\030\003 \001(\0132\022.serum.MarketState\022\035\n\006orders\030\004 \001"
  "(\0132\r.basic.Pubkey\022\"\n\013coin_wallet\030\005 \001(\0132\r"
  ".basic.Pubkey\022 \n\tpc_wallet\030\006 \001(\0132\r.basic"
  ".Pubkey\022\036\n\006signer\030\007 \001(\0132\016.basic.Keypair\""
  "\312\001\n\021ListMarketRequest\022\035\n\005payer\030\001 \001(\0132\016.b"
  "asic.Keypair\022(\n\016dex_program_id\030\002 \001(\0132\020.b"
  "asic.ProgramId\022 \n\tcoin_mint\030\003 \001(\0132\r.basi"
  "c.Pubkey\022\036\n\007pc_mint\030\004 \001(\0132\r.basic.Pubkey"
  "\022\025\n\rcoin_lot_size\030\005 \001(\004\022\023\n\013pc_lot_size\030\006"
  " \001(\004\"[\n\026InitializeTokenAccount\022\033\n\004mint\030\001"
  " \001(\0132\r.basic.Pubkey\022$\n\rowner_account\030\002 \001"
  "(\0132\r.basic.Pubkey\"X\n\rMarketRequest\022(\n\016de"
  "x_program_id\030\001 \001(\0132\020.basic.ProgramId\022\035\n\006"
  "market\030\002 \001(\0132\r.basic.Pubkey*O\n\021SelfTrade"
  "Behavior\022\021\n\rDecrementTake\020\000\022\021\n\rCancelPro"
  "vide\020\001\022\024\n\020AbortTransaction\020\002*;\n\tOrderTyp"
  "e\022\t\n\005Limit\020\000\022\025\n\021ImmediateOrCancel\020\001\022\014\n\010P"
  "ostOnly\020\0022\364\004\n\003Dex\022@\n\020GetMarketPubkeys\022\024."
  "serum.MarketRequest\032\024.serum.MarketPubkey"
  "s\"\000\022C\n\nListMarket\022\030.serum.ListMarketRequ"
  "est\032\031.serum.ListMarketResponse\"\000\022\?\n\rCons"
  "umeEvents\022\033.serum.ConsumeEventsRequest\032\017"
  ".basic.SignedTx\"\000\022\?\n\rInitOpenOrder\022\033.ser"
  "um.InitOpenOrderRequest\032\017.basic.SignedTx"
  "\"\000\022+\n\010NewOrder\022\014.serum.Order\032\017.basic.Sig"
  "nedTx\"\000\022;\n\013CancelOrder\022\031.serum.CancelOrd"
  "erRequest\032\017.basic.SignedTx\"\000\022;\n\013SettleFu"
  "nds\022\031.serum.SettleFundsRequest\032\017.basic.S"
  "ignedTx\"\000\022B\n\017CloseOpenOrders\022\034.serum.Clo"
  "seOpenOrderRequest\032\017.basic.SignedTx\"\000\022;\n"
  "\013MatchOrders\022\031.serum.MatchOrdersRequest\032"
  "\017.basic.SignedTx\"\000\022<\n\014MonitorQueue\022\032.ser"
  "um.MonitorQueueRequest\032\014.serum.Event\"\0000\001"
  "B0Z.github.com/SolmateDev/go-rust-transl"
  "ator/serumb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_proto_2fserum_2eproto_deps[1] = {
  &::descriptor_table_proto_2fbasic_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_proto_2fserum_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fserum_2eproto = {
  false, false, 4058, descriptor_table_protodef_proto_2fserum_2eproto, "proto/serum.proto", 
  &descriptor_table_proto_2fserum_2eproto_once, descriptor_table_proto_2fserum_2eproto_deps, 1, 22,
  schemas, file_default_instances, TableStruct_proto_2fserum_2eproto::offsets,
  file_level_metadata_proto_2fserum_2eproto, file_level_enum_descriptors_proto_2fserum_2eproto, file_level_service_descriptors_proto_2fserum_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_proto_2fserum_2eproto_getter() {
  return &descriptor_table_proto_2fserum_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_proto_2fserum_2eproto(&descriptor_table_proto_2fserum_2eproto);
namespace serum {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelfTradeBehavior_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fserum_2eproto);
  return file_level_enum_descriptors_proto_2fserum_2eproto[0];
}
bool SelfTradeBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fserum_2eproto);
  return file_level_enum_descriptors_proto_2fserum_2eproto[1];
}
bool OrderType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class MarketState::_Internal {
 public:
  static const ::basic::Pubkey& id(const MarketState* msg);
  static const ::serum::MarketPubkeys& state(const MarketState* msg);
};

const ::basic::Pubkey&
MarketState::_Internal::id(const MarketState* msg) {
  return *msg->market_.id_;
}
const ::serum::MarketPubkeys&
MarketState::_Internal::state(const MarketState* msg) {
  return *msg->market_.state_;
}
void MarketState::set_allocated_id(::basic::Pubkey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_market();
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
    market_.id_ = id;
  }
  // @@protoc_insertion_point(field_set_allocated:serum.MarketState.id)
}
void MarketState::clear_id() {
  if (_internal_has_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete market_.id_;
    }
    clear_has_market();
  }
}
void MarketState::set_allocated_state(::serum::MarketPubkeys* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_market();
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::MarketPubkeys>::GetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
    market_.state_ = state;
  }
  // @@protoc_insertion_point(field_set_allocated:serum.MarketState.state)
}
MarketState::MarketState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.MarketState)
}
MarketState::MarketState(const MarketState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_market();
  switch (from.market_case()) {
    case kId: {
      _internal_mutable_id()->::basic::Pubkey::MergeFrom(from._internal_id());
      break;
    }
    case kState: {
      _internal_mutable_state()->::serum::MarketPubkeys::MergeFrom(from._internal_state());
      break;
    }
    case MARKET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serum.MarketState)
}

inline void MarketState::SharedCtor() {
clear_has_market();
}

MarketState::~MarketState() {
  // @@protoc_insertion_point(destructor:serum.MarketState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MarketState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_market()) {
    clear_market();
  }
}

void MarketState::ArenaDtor(void* object) {
  MarketState* _this = reinterpret_cast< MarketState* >(object);
  (void)_this;
}
void MarketState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MarketState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MarketState::clear_market() {
// @@protoc_insertion_point(one_of_clear_start:serum.MarketState)
  switch (market_case()) {
    case kId: {
      if (GetArenaForAllocation() == nullptr) {
        delete market_.id_;
      }
      break;
    }
    case kState: {
      if (GetArenaForAllocation() == nullptr) {
        delete market_.state_;
      }
      break;
    }
    case MARKET_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MARKET_NOT_SET;
}


void MarketState::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.MarketState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_market();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.Pubkey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketPubkeys state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarketState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.MarketState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.Pubkey id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // .serum.MarketPubkeys state = 2;
  if (_internal_has_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.MarketState)
  return target;
}

size_t MarketState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.MarketState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (market_case()) {
    // .basic.Pubkey id = 1;
    case kId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *market_.id_);
      break;
    }
    // .serum.MarketPubkeys state = 2;
    case kState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *market_.state_);
      break;
    }
    case MARKET_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MarketState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketState::GetClassData() const { return &_class_data_; }

void MarketState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MarketState *>(to)->MergeFrom(
      static_cast<const MarketState &>(from));
}


void MarketState::MergeFrom(const MarketState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.MarketState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.market_case()) {
    case kId: {
      _internal_mutable_id()->::basic::Pubkey::MergeFrom(from._internal_id());
      break;
    }
    case kState: {
      _internal_mutable_state()->::serum::MarketPubkeys::MergeFrom(from._internal_state());
      break;
    }
    case MARKET_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketState::CopyFrom(const MarketState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.MarketState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketState::IsInitialized() const {
  return true;
}

void MarketState::InternalSwap(MarketState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(market_, other->market_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[0]);
}

// ===================================================================

class InitOpenOrderRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const InitOpenOrderRequest* msg);
  static const ::basic::Keypair& owner(const InitOpenOrderRequest* msg);
  static const ::serum::MarketState& market(const InitOpenOrderRequest* msg);
  static const ::basic::Pubkey& orders(const InitOpenOrderRequest* msg);
};

const ::basic::ProgramId&
InitOpenOrderRequest::_Internal::dex_program_id(const InitOpenOrderRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Keypair&
InitOpenOrderRequest::_Internal::owner(const InitOpenOrderRequest* msg) {
  return *msg->owner_;
}
const ::serum::MarketState&
InitOpenOrderRequest::_Internal::market(const InitOpenOrderRequest* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
InitOpenOrderRequest::_Internal::orders(const InitOpenOrderRequest* msg) {
  return *msg->orders_;
}
void InitOpenOrderRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void InitOpenOrderRequest::clear_owner() {
  if (GetArenaForAllocation() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
void InitOpenOrderRequest::clear_orders() {
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
}
InitOpenOrderRequest::InitOpenOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.InitOpenOrderRequest)
}
InitOpenOrderRequest::InitOpenOrderRequest(const InitOpenOrderRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_owner()) {
    owner_ = new ::basic::Keypair(*from.owner_);
  } else {
    owner_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_orders()) {
    orders_ = new ::basic::Pubkey(*from.orders_);
  } else {
    orders_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.InitOpenOrderRequest)
}

inline void InitOpenOrderRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&orders_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(orders_));
}

InitOpenOrderRequest::~InitOpenOrderRequest() {
  // @@protoc_insertion_point(destructor:serum.InitOpenOrderRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void InitOpenOrderRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete owner_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete orders_;
}

void InitOpenOrderRequest::ArenaDtor(void* object) {
  InitOpenOrderRequest* _this = reinterpret_cast< InitOpenOrderRequest* >(object);
  (void)_this;
}
void InitOpenOrderRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitOpenOrderRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitOpenOrderRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.InitOpenOrderRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitOpenOrderRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey orders = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_orders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitOpenOrderRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.InitOpenOrderRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Keypair owner = 2;
  if (this->_internal_has_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner(this), target, stream);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::orders(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.InitOpenOrderRequest)
  return target;
}

size_t InitOpenOrderRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.InitOpenOrderRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Keypair owner = 2;
  if (this->_internal_has_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orders_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitOpenOrderRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InitOpenOrderRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitOpenOrderRequest::GetClassData() const { return &_class_data_; }

void InitOpenOrderRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InitOpenOrderRequest *>(to)->MergeFrom(
      static_cast<const InitOpenOrderRequest &>(from));
}


void InitOpenOrderRequest::MergeFrom(const InitOpenOrderRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.InitOpenOrderRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_owner()) {
    _internal_mutable_owner()->::basic::Keypair::MergeFrom(from._internal_owner());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_orders()) {
    _internal_mutable_orders()->::basic::Pubkey::MergeFrom(from._internal_orders());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InitOpenOrderRequest::CopyFrom(const InitOpenOrderRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.InitOpenOrderRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitOpenOrderRequest::IsInitialized() const {
  return true;
}

void InitOpenOrderRequest::InternalSwap(InitOpenOrderRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitOpenOrderRequest, orders_)
      + sizeof(InitOpenOrderRequest::orders_)
      - PROTOBUF_FIELD_OFFSET(InitOpenOrderRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InitOpenOrderRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[1]);
}

// ===================================================================

class CloseOpenOrderRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const CloseOpenOrderRequest* msg);
  static const ::basic::Keypair& owner(const CloseOpenOrderRequest* msg);
  static const ::serum::MarketState& market(const CloseOpenOrderRequest* msg);
  static const ::basic::Pubkey& orders(const CloseOpenOrderRequest* msg);
};

const ::basic::ProgramId&
CloseOpenOrderRequest::_Internal::dex_program_id(const CloseOpenOrderRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Keypair&
CloseOpenOrderRequest::_Internal::owner(const CloseOpenOrderRequest* msg) {
  return *msg->owner_;
}
const ::serum::MarketState&
CloseOpenOrderRequest::_Internal::market(const CloseOpenOrderRequest* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
CloseOpenOrderRequest::_Internal::orders(const CloseOpenOrderRequest* msg) {
  return *msg->orders_;
}
void CloseOpenOrderRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void CloseOpenOrderRequest::clear_owner() {
  if (GetArenaForAllocation() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
void CloseOpenOrderRequest::clear_orders() {
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
}
CloseOpenOrderRequest::CloseOpenOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.CloseOpenOrderRequest)
}
CloseOpenOrderRequest::CloseOpenOrderRequest(const CloseOpenOrderRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_owner()) {
    owner_ = new ::basic::Keypair(*from.owner_);
  } else {
    owner_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_orders()) {
    orders_ = new ::basic::Pubkey(*from.orders_);
  } else {
    orders_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.CloseOpenOrderRequest)
}

inline void CloseOpenOrderRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&orders_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(orders_));
}

CloseOpenOrderRequest::~CloseOpenOrderRequest() {
  // @@protoc_insertion_point(destructor:serum.CloseOpenOrderRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CloseOpenOrderRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete owner_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete orders_;
}

void CloseOpenOrderRequest::ArenaDtor(void* object) {
  CloseOpenOrderRequest* _this = reinterpret_cast< CloseOpenOrderRequest* >(object);
  (void)_this;
}
void CloseOpenOrderRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CloseOpenOrderRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CloseOpenOrderRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.CloseOpenOrderRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CloseOpenOrderRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey orders = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_orders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseOpenOrderRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.CloseOpenOrderRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Keypair owner = 2;
  if (this->_internal_has_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner(this), target, stream);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::orders(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.CloseOpenOrderRequest)
  return target;
}

size_t CloseOpenOrderRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.CloseOpenOrderRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Keypair owner = 2;
  if (this->_internal_has_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orders_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseOpenOrderRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CloseOpenOrderRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseOpenOrderRequest::GetClassData() const { return &_class_data_; }

void CloseOpenOrderRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CloseOpenOrderRequest *>(to)->MergeFrom(
      static_cast<const CloseOpenOrderRequest &>(from));
}


void CloseOpenOrderRequest::MergeFrom(const CloseOpenOrderRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.CloseOpenOrderRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_owner()) {
    _internal_mutable_owner()->::basic::Keypair::MergeFrom(from._internal_owner());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_orders()) {
    _internal_mutable_orders()->::basic::Pubkey::MergeFrom(from._internal_orders());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CloseOpenOrderRequest::CopyFrom(const CloseOpenOrderRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.CloseOpenOrderRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseOpenOrderRequest::IsInitialized() const {
  return true;
}

void CloseOpenOrderRequest::InternalSwap(CloseOpenOrderRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CloseOpenOrderRequest, orders_)
      + sizeof(CloseOpenOrderRequest::orders_)
      - PROTOBUF_FIELD_OFFSET(CloseOpenOrderRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CloseOpenOrderRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[2]);
}

// ===================================================================

class CancelOrderRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const CancelOrderRequest* msg);
  static const ::basic::Keypair& owner(const CancelOrderRequest* msg);
  static const ::serum::MarketState& market(const CancelOrderRequest* msg);
  static const ::basic::Pubkey& orders(const CancelOrderRequest* msg);
};

const ::basic::ProgramId&
CancelOrderRequest::_Internal::dex_program_id(const CancelOrderRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Keypair&
CancelOrderRequest::_Internal::owner(const CancelOrderRequest* msg) {
  return *msg->owner_;
}
const ::serum::MarketState&
CancelOrderRequest::_Internal::market(const CancelOrderRequest* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
CancelOrderRequest::_Internal::orders(const CancelOrderRequest* msg) {
  return *msg->orders_;
}
void CancelOrderRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void CancelOrderRequest::clear_owner() {
  if (GetArenaForAllocation() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
void CancelOrderRequest::clear_orders() {
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
}
CancelOrderRequest::CancelOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.CancelOrderRequest)
}
CancelOrderRequest::CancelOrderRequest(const CancelOrderRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_owner()) {
    owner_ = new ::basic::Keypair(*from.owner_);
  } else {
    owner_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_orders()) {
    orders_ = new ::basic::Pubkey(*from.orders_);
  } else {
    orders_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:serum.CancelOrderRequest)
}

inline void CancelOrderRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(id_));
}

CancelOrderRequest::~CancelOrderRequest() {
  // @@protoc_insertion_point(destructor:serum.CancelOrderRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CancelOrderRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete owner_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete orders_;
}

void CancelOrderRequest::ArenaDtor(void* object) {
  CancelOrderRequest* _this = reinterpret_cast< CancelOrderRequest* >(object);
  (void)_this;
}
void CancelOrderRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CancelOrderRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CancelOrderRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.CancelOrderRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
  id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CancelOrderRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey orders = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_orders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CancelOrderRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.CancelOrderRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Keypair owner = 2;
  if (this->_internal_has_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner(this), target, stream);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::orders(this), target, stream);
  }

  // uint64 id = 5;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.CancelOrderRequest)
  return target;
}

size_t CancelOrderRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.CancelOrderRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Keypair owner = 2;
  if (this->_internal_has_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orders_);
  }

  // uint64 id = 5;
  if (this->_internal_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CancelOrderRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CancelOrderRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CancelOrderRequest::GetClassData() const { return &_class_data_; }

void CancelOrderRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CancelOrderRequest *>(to)->MergeFrom(
      static_cast<const CancelOrderRequest &>(from));
}


void CancelOrderRequest::MergeFrom(const CancelOrderRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.CancelOrderRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_owner()) {
    _internal_mutable_owner()->::basic::Keypair::MergeFrom(from._internal_owner());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_orders()) {
    _internal_mutable_orders()->::basic::Pubkey::MergeFrom(from._internal_orders());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CancelOrderRequest::CopyFrom(const CancelOrderRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.CancelOrderRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelOrderRequest::IsInitialized() const {
  return true;
}

void CancelOrderRequest::InternalSwap(CancelOrderRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CancelOrderRequest, id_)
      + sizeof(CancelOrderRequest::id_)
      - PROTOBUF_FIELD_OFFSET(CancelOrderRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CancelOrderRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[3]);
}

// ===================================================================

class ListMarketResponse::_Internal {
 public:
  static const ::serum::MarketPubkeys& market_pubkeys(const ListMarketResponse* msg);
  static const ::basic::SignedTx& tx(const ListMarketResponse* msg);
};

const ::serum::MarketPubkeys&
ListMarketResponse::_Internal::market_pubkeys(const ListMarketResponse* msg) {
  return *msg->market_pubkeys_;
}
const ::basic::SignedTx&
ListMarketResponse::_Internal::tx(const ListMarketResponse* msg) {
  return *msg->tx_;
}
void ListMarketResponse::clear_tx() {
  if (GetArenaForAllocation() == nullptr && tx_ != nullptr) {
    delete tx_;
  }
  tx_ = nullptr;
}
ListMarketResponse::ListMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.ListMarketResponse)
}
ListMarketResponse::ListMarketResponse(const ListMarketResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_market_pubkeys()) {
    market_pubkeys_ = new ::serum::MarketPubkeys(*from.market_pubkeys_);
  } else {
    market_pubkeys_ = nullptr;
  }
  if (from._internal_has_tx()) {
    tx_ = new ::basic::SignedTx(*from.tx_);
  } else {
    tx_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.ListMarketResponse)
}

inline void ListMarketResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&market_pubkeys_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tx_) -
    reinterpret_cast<char*>(&market_pubkeys_)) + sizeof(tx_));
}

ListMarketResponse::~ListMarketResponse() {
  // @@protoc_insertion_point(destructor:serum.ListMarketResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListMarketResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete market_pubkeys_;
  if (this != internal_default_instance()) delete tx_;
}

void ListMarketResponse::ArenaDtor(void* object) {
  ListMarketResponse* _this = reinterpret_cast< ListMarketResponse* >(object);
  (void)_this;
}
void ListMarketResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListMarketResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListMarketResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.ListMarketResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && market_pubkeys_ != nullptr) {
    delete market_pubkeys_;
  }
  market_pubkeys_ = nullptr;
  if (GetArenaForAllocation() == nullptr && tx_ != nullptr) {
    delete tx_;
  }
  tx_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListMarketResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serum.MarketPubkeys market_pubkeys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_pubkeys(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.SignedTx tx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tx(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListMarketResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.ListMarketResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serum.MarketPubkeys market_pubkeys = 1;
  if (this->_internal_has_market_pubkeys()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::market_pubkeys(this), target, stream);
  }

  // .basic.SignedTx tx = 2;
  if (this->_internal_has_tx()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::tx(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.ListMarketResponse)
  return target;
}

size_t ListMarketResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.ListMarketResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .serum.MarketPubkeys market_pubkeys = 1;
  if (this->_internal_has_market_pubkeys()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_pubkeys_);
  }

  // .basic.SignedTx tx = 2;
  if (this->_internal_has_tx()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tx_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListMarketResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListMarketResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListMarketResponse::GetClassData() const { return &_class_data_; }

void ListMarketResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListMarketResponse *>(to)->MergeFrom(
      static_cast<const ListMarketResponse &>(from));
}


void ListMarketResponse::MergeFrom(const ListMarketResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.ListMarketResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_market_pubkeys()) {
    _internal_mutable_market_pubkeys()->::serum::MarketPubkeys::MergeFrom(from._internal_market_pubkeys());
  }
  if (from._internal_has_tx()) {
    _internal_mutable_tx()->::basic::SignedTx::MergeFrom(from._internal_tx());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListMarketResponse::CopyFrom(const ListMarketResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.ListMarketResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListMarketResponse::IsInitialized() const {
  return true;
}

void ListMarketResponse::InternalSwap(ListMarketResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListMarketResponse, tx_)
      + sizeof(ListMarketResponse::tx_)
      - PROTOBUF_FIELD_OFFSET(ListMarketResponse, market_pubkeys_)>(
          reinterpret_cast<char*>(&market_pubkeys_),
          reinterpret_cast<char*>(&other->market_pubkeys_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListMarketResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[4]);
}

// ===================================================================

class Order::_Internal {
 public:
  static const ::serum::NewOrderInstructionV3& v3(const Order* msg);
  static const ::basic::ProgramId& dex_program_id(const Order* msg);
  static const ::basic::Keypair& payer(const Order* msg);
  static const ::basic::Pubkey& wallet(const Order* msg);
  static const ::serum::MarketState& market(const Order* msg);
  static const ::basic::Pubkey& orders(const Order* msg);
};

const ::serum::NewOrderInstructionV3&
Order::_Internal::v3(const Order* msg) {
  return *msg->order_.v3_;
}
const ::basic::ProgramId&
Order::_Internal::dex_program_id(const Order* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Keypair&
Order::_Internal::payer(const Order* msg) {
  return *msg->payer_;
}
const ::basic::Pubkey&
Order::_Internal::wallet(const Order* msg) {
  return *msg->wallet_;
}
const ::serum::MarketState&
Order::_Internal::market(const Order* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
Order::_Internal::orders(const Order* msg) {
  return *msg->orders_;
}
void Order::set_allocated_v3(::serum::NewOrderInstructionV3* v3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_order();
  if (v3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::NewOrderInstructionV3>::GetOwningArena(v3);
    if (message_arena != submessage_arena) {
      v3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v3, submessage_arena);
    }
    set_has_v3();
    order_.v3_ = v3;
  }
  // @@protoc_insertion_point(field_set_allocated:serum.Order.v3)
}
void Order::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void Order::clear_payer() {
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
}
void Order::clear_wallet() {
  if (GetArenaForAllocation() == nullptr && wallet_ != nullptr) {
    delete wallet_;
  }
  wallet_ = nullptr;
}
void Order::clear_orders() {
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
}
Order::Order(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.Order)
}
Order::Order(const Order& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_payer()) {
    payer_ = new ::basic::Keypair(*from.payer_);
  } else {
    payer_ = nullptr;
  }
  if (from._internal_has_wallet()) {
    wallet_ = new ::basic::Pubkey(*from.wallet_);
  } else {
    wallet_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_orders()) {
    orders_ = new ::basic::Pubkey(*from.orders_);
  } else {
    orders_ = nullptr;
  }
  clear_has_order();
  switch (from.order_case()) {
    case kV3: {
      _internal_mutable_v3()->::serum::NewOrderInstructionV3::MergeFrom(from._internal_v3());
      break;
    }
    case ORDER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serum.Order)
}

inline void Order::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&orders_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(orders_));
clear_has_order();
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:serum.Order)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Order::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete payer_;
  if (this != internal_default_instance()) delete wallet_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete orders_;
  if (has_order()) {
    clear_order();
  }
}

void Order::ArenaDtor(void* object) {
  Order* _this = reinterpret_cast< Order* >(object);
  (void)_this;
}
void Order::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Order::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Order::clear_order() {
// @@protoc_insertion_point(one_of_clear_start:serum.Order)
  switch (order_case()) {
    case kV3: {
      if (GetArenaForAllocation() == nullptr) {
        delete order_.v3_;
      }
      break;
    }
    case ORDER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ORDER_NOT_SET;
}


void Order::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.Order)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && wallet_ != nullptr) {
    delete wallet_;
  }
  wallet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
  clear_order();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Order::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serum.NewOrderInstructionV3 v3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_v3(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.ProgramId dex_program_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair payer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_payer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey wallet = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey orders = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_orders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Order::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.Order)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serum.NewOrderInstructionV3 v3 = 1;
  if (_internal_has_v3()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::v3(this), target, stream);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Keypair payer = 3;
  if (this->_internal_has_payer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::payer(this), target, stream);
  }

  // .basic.Pubkey wallet = 4;
  if (this->_internal_has_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::wallet(this), target, stream);
  }

  // .serum.MarketState market = 5;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey orders = 6;
  if (this->_internal_has_orders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::orders(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.Order)
  return target;
}

size_t Order::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.Order)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Keypair payer = 3;
  if (this->_internal_has_payer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *payer_);
  }

  // .basic.Pubkey wallet = 4;
  if (this->_internal_has_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *wallet_);
  }

  // .serum.MarketState market = 5;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey orders = 6;
  if (this->_internal_has_orders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orders_);
  }

  switch (order_case()) {
    // .serum.NewOrderInstructionV3 v3 = 1;
    case kV3: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *order_.v3_);
      break;
    }
    case ORDER_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Order::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Order::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Order::GetClassData() const { return &_class_data_; }

void Order::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Order *>(to)->MergeFrom(
      static_cast<const Order &>(from));
}


void Order::MergeFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.Order)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_payer()) {
    _internal_mutable_payer()->::basic::Keypair::MergeFrom(from._internal_payer());
  }
  if (from._internal_has_wallet()) {
    _internal_mutable_wallet()->::basic::Pubkey::MergeFrom(from._internal_wallet());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_orders()) {
    _internal_mutable_orders()->::basic::Pubkey::MergeFrom(from._internal_orders());
  }
  switch (from.order_case()) {
    case kV3: {
      _internal_mutable_v3()->::serum::NewOrderInstructionV3::MergeFrom(from._internal_v3());
      break;
    }
    case ORDER_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Order::CopyFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  return true;
}

void Order::InternalSwap(Order* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Order, orders_)
      + sizeof(Order::orders_)
      - PROTOBUF_FIELD_OFFSET(Order, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
  swap(order_, other->order_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Order::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[5]);
}

// ===================================================================

class OrderStatus::_Internal {
 public:
  static const ::basic::TxStatusWithSlot& status_with_slot(const OrderStatus* msg);
};

const ::basic::TxStatusWithSlot&
OrderStatus::_Internal::status_with_slot(const OrderStatus* msg) {
  return *msg->status_with_slot_;
}
void OrderStatus::clear_status_with_slot() {
  if (GetArenaForAllocation() == nullptr && status_with_slot_ != nullptr) {
    delete status_with_slot_;
  }
  status_with_slot_ = nullptr;
}
OrderStatus::OrderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.OrderStatus)
}
OrderStatus::OrderStatus(const OrderStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_status_with_slot()) {
    status_with_slot_ = new ::basic::TxStatusWithSlot(*from.status_with_slot_);
  } else {
    status_with_slot_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.OrderStatus)
}

inline void OrderStatus::SharedCtor() {
status_with_slot_ = nullptr;
}

OrderStatus::~OrderStatus() {
  // @@protoc_insertion_point(destructor:serum.OrderStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OrderStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_with_slot_;
}

void OrderStatus::ArenaDtor(void* object) {
  OrderStatus* _this = reinterpret_cast< OrderStatus* >(object);
  (void)_this;
}
void OrderStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OrderStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OrderStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.OrderStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && status_with_slot_ != nullptr) {
    delete status_with_slot_;
  }
  status_with_slot_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.TxStatusWithSlot status_with_slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status_with_slot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OrderStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.OrderStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.TxStatusWithSlot status_with_slot = 1;
  if (this->_internal_has_status_with_slot()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::status_with_slot(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.OrderStatus)
  return target;
}

size_t OrderStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.OrderStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.TxStatusWithSlot status_with_slot = 1;
  if (this->_internal_has_status_with_slot()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_with_slot_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OrderStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderStatus::GetClassData() const { return &_class_data_; }

void OrderStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OrderStatus *>(to)->MergeFrom(
      static_cast<const OrderStatus &>(from));
}


void OrderStatus::MergeFrom(const OrderStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.OrderStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status_with_slot()) {
    _internal_mutable_status_with_slot()->::basic::TxStatusWithSlot::MergeFrom(from._internal_status_with_slot());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderStatus::CopyFrom(const OrderStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.OrderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderStatus::IsInitialized() const {
  return true;
}

void OrderStatus::InternalSwap(OrderStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(status_with_slot_, other->status_with_slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[6]);
}

// ===================================================================

class NewOrderInstructionV3::_Internal {
 public:
};

NewOrderInstructionV3::NewOrderInstructionV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.NewOrderInstructionV3)
}
NewOrderInstructionV3::NewOrderInstructionV3(const NewOrderInstructionV3& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&limit_price_, &from.limit_price_,
    static_cast<size_t>(reinterpret_cast<char*>(&limit_) -
    reinterpret_cast<char*>(&limit_price_)) + sizeof(limit_));
  // @@protoc_insertion_point(copy_constructor:serum.NewOrderInstructionV3)
}

inline void NewOrderInstructionV3::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&limit_price_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&limit_) -
    reinterpret_cast<char*>(&limit_price_)) + sizeof(limit_));
}

NewOrderInstructionV3::~NewOrderInstructionV3() {
  // @@protoc_insertion_point(destructor:serum.NewOrderInstructionV3)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NewOrderInstructionV3::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NewOrderInstructionV3::ArenaDtor(void* object) {
  NewOrderInstructionV3* _this = reinterpret_cast< NewOrderInstructionV3* >(object);
  (void)_this;
}
void NewOrderInstructionV3::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NewOrderInstructionV3::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NewOrderInstructionV3::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.NewOrderInstructionV3)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&limit_price_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_) -
      reinterpret_cast<char*>(&limit_price_)) + sizeof(limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewOrderInstructionV3::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          side_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 limit_price = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          limit_price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_coin_qty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          max_coin_qty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_native_pc_qty_including_fees = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          max_native_pc_qty_including_fees_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.SelfTradeBehavior self_trade_behavior = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_self_trade_behavior(static_cast<::serum::SelfTradeBehavior>(val));
        } else
          goto handle_unusual;
        continue;
      // .serum.OrderType order_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::serum::OrderType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 client_order_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          client_order_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 limit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewOrderInstructionV3::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.NewOrderInstructionV3)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool side = 1;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_side(), target);
  }

  // uint64 limit_price = 2;
  if (this->_internal_limit_price() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_limit_price(), target);
  }

  // uint64 max_coin_qty = 3;
  if (this->_internal_max_coin_qty() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_coin_qty(), target);
  }

  // uint64 max_native_pc_qty_including_fees = 4;
  if (this->_internal_max_native_pc_qty_including_fees() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_max_native_pc_qty_including_fees(), target);
  }

  // .serum.SelfTradeBehavior self_trade_behavior = 5;
  if (this->_internal_self_trade_behavior() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_self_trade_behavior(), target);
  }

  // .serum.OrderType order_type = 6;
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_order_type(), target);
  }

  // uint64 client_order_id = 7;
  if (this->_internal_client_order_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_client_order_id(), target);
  }

  // uint32 limit = 8;
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.NewOrderInstructionV3)
  return target;
}

size_t NewOrderInstructionV3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.NewOrderInstructionV3)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 limit_price = 2;
  if (this->_internal_limit_price() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_limit_price());
  }

  // uint64 max_coin_qty = 3;
  if (this->_internal_max_coin_qty() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_coin_qty());
  }

  // bool side = 1;
  if (this->_internal_side() != 0) {
    total_size += 1 + 1;
  }

  // .serum.SelfTradeBehavior self_trade_behavior = 5;
  if (this->_internal_self_trade_behavior() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_self_trade_behavior());
  }

  // uint64 max_native_pc_qty_including_fees = 4;
  if (this->_internal_max_native_pc_qty_including_fees() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_native_pc_qty_including_fees());
  }

  // uint64 client_order_id = 7;
  if (this->_internal_client_order_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_order_id());
  }

  // .serum.OrderType order_type = 6;
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  // uint32 limit = 8;
  if (this->_internal_limit() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewOrderInstructionV3::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NewOrderInstructionV3::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewOrderInstructionV3::GetClassData() const { return &_class_data_; }

void NewOrderInstructionV3::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NewOrderInstructionV3 *>(to)->MergeFrom(
      static_cast<const NewOrderInstructionV3 &>(from));
}


void NewOrderInstructionV3::MergeFrom(const NewOrderInstructionV3& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.NewOrderInstructionV3)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_limit_price() != 0) {
    _internal_set_limit_price(from._internal_limit_price());
  }
  if (from._internal_max_coin_qty() != 0) {
    _internal_set_max_coin_qty(from._internal_max_coin_qty());
  }
  if (from._internal_side() != 0) {
    _internal_set_side(from._internal_side());
  }
  if (from._internal_self_trade_behavior() != 0) {
    _internal_set_self_trade_behavior(from._internal_self_trade_behavior());
  }
  if (from._internal_max_native_pc_qty_including_fees() != 0) {
    _internal_set_max_native_pc_qty_including_fees(from._internal_max_native_pc_qty_including_fees());
  }
  if (from._internal_client_order_id() != 0) {
    _internal_set_client_order_id(from._internal_client_order_id());
  }
  if (from._internal_order_type() != 0) {
    _internal_set_order_type(from._internal_order_type());
  }
  if (from._internal_limit() != 0) {
    _internal_set_limit(from._internal_limit());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewOrderInstructionV3::CopyFrom(const NewOrderInstructionV3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.NewOrderInstructionV3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewOrderInstructionV3::IsInitialized() const {
  return true;
}

void NewOrderInstructionV3::InternalSwap(NewOrderInstructionV3* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewOrderInstructionV3, limit_)
      + sizeof(NewOrderInstructionV3::limit_)
      - PROTOBUF_FIELD_OFFSET(NewOrderInstructionV3, limit_price_)>(
          reinterpret_cast<char*>(&limit_price_),
          reinterpret_cast<char*>(&other->limit_price_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewOrderInstructionV3::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[7]);
}

// ===================================================================

class Event::_Internal {
 public:
  static const ::serum::Bid& bid(const Event* msg);
  static const ::serum::Ask& ask(const Event* msg);
};

const ::serum::Bid&
Event::_Internal::bid(const Event* msg) {
  return *msg->event_.bid_;
}
const ::serum::Ask&
Event::_Internal::ask(const Event* msg) {
  return *msg->event_.ask_;
}
void Event::set_allocated_bid(::serum::Bid* bid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (bid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::Bid>::GetOwningArena(bid);
    if (message_arena != submessage_arena) {
      bid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bid, submessage_arena);
    }
    set_has_bid();
    event_.bid_ = bid;
  }
  // @@protoc_insertion_point(field_set_allocated:serum.Event.bid)
}
void Event::set_allocated_ask(::serum::Ask* ask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (ask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serum::Ask>::GetOwningArena(ask);
    if (message_arena != submessage_arena) {
      ask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ask, submessage_arena);
    }
    set_has_ask();
    event_.ask_ = ask;
  }
  // @@protoc_insertion_point(field_set_allocated:serum.Event.ask)
}
Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_event();
  switch (from.event_case()) {
    case kBid: {
      _internal_mutable_bid()->::serum::Bid::MergeFrom(from._internal_bid());
      break;
    }
    case kAsk: {
      _internal_mutable_ask()->::serum::Ask::MergeFrom(from._internal_ask());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:serum.Event)
}

inline void Event::SharedCtor() {
clear_has_event();
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:serum.Event)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_event()) {
    clear_event();
  }
}

void Event::ArenaDtor(void* object) {
  Event* _this = reinterpret_cast< Event* >(object);
  (void)_this;
}
void Event::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Event::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:serum.Event)
  switch (event_case()) {
    case kBid: {
      if (GetArenaForAllocation() == nullptr) {
        delete event_.bid_;
      }
      break;
    }
    case kAsk: {
      if (GetArenaForAllocation() == nullptr) {
        delete event_.ask_;
      }
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EVENT_NOT_SET;
}


void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_event();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Event::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .serum.Bid bid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_bid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.Ask ask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .serum.Bid bid = 1;
  if (_internal_has_bid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::bid(this), target, stream);
  }

  // .serum.Ask ask = 2;
  if (_internal_has_ask()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ask(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (event_case()) {
    // .serum.Bid bid = 1;
    case kBid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *event_.bid_);
      break;
    }
    // .serum.Ask ask = 2;
    case kAsk: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *event_.ask_);
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Event::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Event::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Event::GetClassData() const { return &_class_data_; }

void Event::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Event *>(to)->MergeFrom(
      static_cast<const Event &>(from));
}


void Event::MergeFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.Event)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.event_case()) {
    case kBid: {
      _internal_mutable_bid()->::serum::Bid::MergeFrom(from._internal_bid());
      break;
    }
    case kAsk: {
      _internal_mutable_ask()->::serum::Ask::MergeFrom(from._internal_ask());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(event_, other->event_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[8]);
}

// ===================================================================

class Bid::_Internal {
 public:
};

Bid::Bid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:serum.Bid)
}
Bid::Bid(const Bid& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:serum.Bid)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bid::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bid::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Bid::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[9]);
}

// ===================================================================

class Ask::_Internal {
 public:
};

Ask::Ask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:serum.Ask)
}
Ask::Ask(const Ask& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:serum.Ask)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ask::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ask::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Ask::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[10]);
}

// ===================================================================

class ConsumeEventUpdate::_Internal {
 public:
};

ConsumeEventUpdate::ConsumeEventUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.ConsumeEventUpdate)
}
ConsumeEventUpdate::ConsumeEventUpdate(const ConsumeEventUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArenaForAllocation());
  }
  crank_count_ = from.crank_count_;
  // @@protoc_insertion_point(copy_constructor:serum.ConsumeEventUpdate)
}

inline void ConsumeEventUpdate::SharedCtor() {
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
crank_count_ = int64_t{0};
}

ConsumeEventUpdate::~ConsumeEventUpdate() {
  // @@protoc_insertion_point(destructor:serum.ConsumeEventUpdate)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConsumeEventUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ConsumeEventUpdate::ArenaDtor(void* object) {
  ConsumeEventUpdate* _this = reinterpret_cast< ConsumeEventUpdate* >(object);
  (void)_this;
}
void ConsumeEventUpdate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConsumeEventUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConsumeEventUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.ConsumeEventUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_.ClearToEmpty();
  crank_count_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsumeEventUpdate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 crank_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          crank_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "serum.ConsumeEventUpdate.status"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConsumeEventUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.ConsumeEventUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 crank_count = 1;
  if (this->_internal_crank_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_crank_count(), target);
  }

  // string status = 2;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "serum.ConsumeEventUpdate.status");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.ConsumeEventUpdate)
  return target;
}

size_t ConsumeEventUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.ConsumeEventUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 2;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  // int64 crank_count = 1;
  if (this->_internal_crank_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_crank_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsumeEventUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConsumeEventUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsumeEventUpdate::GetClassData() const { return &_class_data_; }

void ConsumeEventUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConsumeEventUpdate *>(to)->MergeFrom(
      static_cast<const ConsumeEventUpdate &>(from));
}


void ConsumeEventUpdate::MergeFrom(const ConsumeEventUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.ConsumeEventUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _internal_set_status(from._internal_status());
  }
  if (from._internal_crank_count() != 0) {
    _internal_set_crank_count(from._internal_crank_count());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsumeEventUpdate::CopyFrom(const ConsumeEventUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.ConsumeEventUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsumeEventUpdate::IsInitialized() const {
  return true;
}

void ConsumeEventUpdate::InternalSwap(ConsumeEventUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
  swap(crank_count_, other->crank_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsumeEventUpdate::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[11]);
}

// ===================================================================

class MarketPubkeys::_Internal {
 public:
  static const ::basic::Pubkey& market(const MarketPubkeys* msg);
  static const ::basic::Pubkey& req_q(const MarketPubkeys* msg);
  static const ::basic::Pubkey& event_q(const MarketPubkeys* msg);
  static const ::basic::Pubkey& bids(const MarketPubkeys* msg);
  static const ::basic::Pubkey& asks(const MarketPubkeys* msg);
  static const ::basic::Pubkey& coin_vault(const MarketPubkeys* msg);
  static const ::basic::Pubkey& pc_vault(const MarketPubkeys* msg);
  static const ::basic::Pubkey& vault_signer_key(const MarketPubkeys* msg);
};

const ::basic::Pubkey&
MarketPubkeys::_Internal::market(const MarketPubkeys* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::req_q(const MarketPubkeys* msg) {
  return *msg->req_q_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::event_q(const MarketPubkeys* msg) {
  return *msg->event_q_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::bids(const MarketPubkeys* msg) {
  return *msg->bids_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::asks(const MarketPubkeys* msg) {
  return *msg->asks_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::coin_vault(const MarketPubkeys* msg) {
  return *msg->coin_vault_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::pc_vault(const MarketPubkeys* msg) {
  return *msg->pc_vault_;
}
const ::basic::Pubkey&
MarketPubkeys::_Internal::vault_signer_key(const MarketPubkeys* msg) {
  return *msg->vault_signer_key_;
}
void MarketPubkeys::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
void MarketPubkeys::clear_req_q() {
  if (GetArenaForAllocation() == nullptr && req_q_ != nullptr) {
    delete req_q_;
  }
  req_q_ = nullptr;
}
void MarketPubkeys::clear_event_q() {
  if (GetArenaForAllocation() == nullptr && event_q_ != nullptr) {
    delete event_q_;
  }
  event_q_ = nullptr;
}
void MarketPubkeys::clear_bids() {
  if (GetArenaForAllocation() == nullptr && bids_ != nullptr) {
    delete bids_;
  }
  bids_ = nullptr;
}
void MarketPubkeys::clear_asks() {
  if (GetArenaForAllocation() == nullptr && asks_ != nullptr) {
    delete asks_;
  }
  asks_ = nullptr;
}
void MarketPubkeys::clear_coin_vault() {
  if (GetArenaForAllocation() == nullptr && coin_vault_ != nullptr) {
    delete coin_vault_;
  }
  coin_vault_ = nullptr;
}
void MarketPubkeys::clear_pc_vault() {
  if (GetArenaForAllocation() == nullptr && pc_vault_ != nullptr) {
    delete pc_vault_;
  }
  pc_vault_ = nullptr;
}
void MarketPubkeys::clear_vault_signer_key() {
  if (GetArenaForAllocation() == nullptr && vault_signer_key_ != nullptr) {
    delete vault_signer_key_;
  }
  vault_signer_key_ = nullptr;
}
MarketPubkeys::MarketPubkeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.MarketPubkeys)
}
MarketPubkeys::MarketPubkeys(const MarketPubkeys& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_market()) {
    market_ = new ::basic::Pubkey(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_req_q()) {
    req_q_ = new ::basic::Pubkey(*from.req_q_);
  } else {
    req_q_ = nullptr;
  }
  if (from._internal_has_event_q()) {
    event_q_ = new ::basic::Pubkey(*from.event_q_);
  } else {
    event_q_ = nullptr;
  }
  if (from._internal_has_bids()) {
    bids_ = new ::basic::Pubkey(*from.bids_);
  } else {
    bids_ = nullptr;
  }
  if (from._internal_has_asks()) {
    asks_ = new ::basic::Pubkey(*from.asks_);
  } else {
    asks_ = nullptr;
  }
  if (from._internal_has_coin_vault()) {
    coin_vault_ = new ::basic::Pubkey(*from.coin_vault_);
  } else {
    coin_vault_ = nullptr;
  }
  if (from._internal_has_pc_vault()) {
    pc_vault_ = new ::basic::Pubkey(*from.pc_vault_);
  } else {
    pc_vault_ = nullptr;
  }
  if (from._internal_has_vault_signer_key()) {
    vault_signer_key_ = new ::basic::Pubkey(*from.vault_signer_key_);
  } else {
    vault_signer_key_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.MarketPubkeys)
}

inline void MarketPubkeys::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&market_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vault_signer_key_) -
    reinterpret_cast<char*>(&market_)) + sizeof(vault_signer_key_));
}

MarketPubkeys::~MarketPubkeys() {
  // @@protoc_insertion_point(destructor:serum.MarketPubkeys)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MarketPubkeys::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete req_q_;
  if (this != internal_default_instance()) delete event_q_;
  if (this != internal_default_instance()) delete bids_;
  if (this != internal_default_instance()) delete asks_;
  if (this != internal_default_instance()) delete coin_vault_;
  if (this != internal_default_instance()) delete pc_vault_;
  if (this != internal_default_instance()) delete vault_signer_key_;
}

void MarketPubkeys::ArenaDtor(void* object) {
  MarketPubkeys* _this = reinterpret_cast< MarketPubkeys* >(object);
  (void)_this;
}
void MarketPubkeys::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MarketPubkeys::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MarketPubkeys::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.MarketPubkeys)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && req_q_ != nullptr) {
    delete req_q_;
  }
  req_q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && event_q_ != nullptr) {
    delete event_q_;
  }
  event_q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bids_ != nullptr) {
    delete bids_;
  }
  bids_ = nullptr;
  if (GetArenaForAllocation() == nullptr && asks_ != nullptr) {
    delete asks_;
  }
  asks_ = nullptr;
  if (GetArenaForAllocation() == nullptr && coin_vault_ != nullptr) {
    delete coin_vault_;
  }
  coin_vault_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pc_vault_ != nullptr) {
    delete pc_vault_;
  }
  pc_vault_ = nullptr;
  if (GetArenaForAllocation() == nullptr && vault_signer_key_ != nullptr) {
    delete vault_signer_key_;
  }
  vault_signer_key_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketPubkeys::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.Pubkey market = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey req_q = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_req_q(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey event_q = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_event_q(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey bids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bids(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey asks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_asks(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey coin_vault = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_vault(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey pc_vault = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_pc_vault(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey vault_signer_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_vault_signer_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarketPubkeys::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.MarketPubkeys)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.Pubkey market = 1;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey req_q = 2;
  if (this->_internal_has_req_q()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::req_q(this), target, stream);
  }

  // .basic.Pubkey event_q = 3;
  if (this->_internal_has_event_q()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::event_q(this), target, stream);
  }

  // .basic.Pubkey bids = 4;
  if (this->_internal_has_bids()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::bids(this), target, stream);
  }

  // .basic.Pubkey asks = 5;
  if (this->_internal_has_asks()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::asks(this), target, stream);
  }

  // .basic.Pubkey coin_vault = 6;
  if (this->_internal_has_coin_vault()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::coin_vault(this), target, stream);
  }

  // .basic.Pubkey pc_vault = 7;
  if (this->_internal_has_pc_vault()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::pc_vault(this), target, stream);
  }

  // .basic.Pubkey vault_signer_key = 8;
  if (this->_internal_has_vault_signer_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::vault_signer_key(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.MarketPubkeys)
  return target;
}

size_t MarketPubkeys::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.MarketPubkeys)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.Pubkey market = 1;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey req_q = 2;
  if (this->_internal_has_req_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *req_q_);
  }

  // .basic.Pubkey event_q = 3;
  if (this->_internal_has_event_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *event_q_);
  }

  // .basic.Pubkey bids = 4;
  if (this->_internal_has_bids()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bids_);
  }

  // .basic.Pubkey asks = 5;
  if (this->_internal_has_asks()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *asks_);
  }

  // .basic.Pubkey coin_vault = 6;
  if (this->_internal_has_coin_vault()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coin_vault_);
  }

  // .basic.Pubkey pc_vault = 7;
  if (this->_internal_has_pc_vault()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pc_vault_);
  }

  // .basic.Pubkey vault_signer_key = 8;
  if (this->_internal_has_vault_signer_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *vault_signer_key_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketPubkeys::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MarketPubkeys::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketPubkeys::GetClassData() const { return &_class_data_; }

void MarketPubkeys::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MarketPubkeys *>(to)->MergeFrom(
      static_cast<const MarketPubkeys &>(from));
}


void MarketPubkeys::MergeFrom(const MarketPubkeys& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.MarketPubkeys)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_market()) {
    _internal_mutable_market()->::basic::Pubkey::MergeFrom(from._internal_market());
  }
  if (from._internal_has_req_q()) {
    _internal_mutable_req_q()->::basic::Pubkey::MergeFrom(from._internal_req_q());
  }
  if (from._internal_has_event_q()) {
    _internal_mutable_event_q()->::basic::Pubkey::MergeFrom(from._internal_event_q());
  }
  if (from._internal_has_bids()) {
    _internal_mutable_bids()->::basic::Pubkey::MergeFrom(from._internal_bids());
  }
  if (from._internal_has_asks()) {
    _internal_mutable_asks()->::basic::Pubkey::MergeFrom(from._internal_asks());
  }
  if (from._internal_has_coin_vault()) {
    _internal_mutable_coin_vault()->::basic::Pubkey::MergeFrom(from._internal_coin_vault());
  }
  if (from._internal_has_pc_vault()) {
    _internal_mutable_pc_vault()->::basic::Pubkey::MergeFrom(from._internal_pc_vault());
  }
  if (from._internal_has_vault_signer_key()) {
    _internal_mutable_vault_signer_key()->::basic::Pubkey::MergeFrom(from._internal_vault_signer_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketPubkeys::CopyFrom(const MarketPubkeys& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.MarketPubkeys)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketPubkeys::IsInitialized() const {
  return true;
}

void MarketPubkeys::InternalSwap(MarketPubkeys* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarketPubkeys, vault_signer_key_)
      + sizeof(MarketPubkeys::vault_signer_key_)
      - PROTOBUF_FIELD_OFFSET(MarketPubkeys, market_)>(
          reinterpret_cast<char*>(&market_),
          reinterpret_cast<char*>(&other->market_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketPubkeys::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[12]);
}

// ===================================================================

class ConsumeEventsRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const ConsumeEventsRequest* msg);
  static const ::basic::Keypair& payer(const ConsumeEventsRequest* msg);
  static const ::serum::MarketState& market(const ConsumeEventsRequest* msg);
  static const ::basic::Pubkey& coin_wallet(const ConsumeEventsRequest* msg);
  static const ::basic::Pubkey& pc_wallet(const ConsumeEventsRequest* msg);
};

const ::basic::ProgramId&
ConsumeEventsRequest::_Internal::dex_program_id(const ConsumeEventsRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Keypair&
ConsumeEventsRequest::_Internal::payer(const ConsumeEventsRequest* msg) {
  return *msg->payer_;
}
const ::serum::MarketState&
ConsumeEventsRequest::_Internal::market(const ConsumeEventsRequest* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
ConsumeEventsRequest::_Internal::coin_wallet(const ConsumeEventsRequest* msg) {
  return *msg->coin_wallet_;
}
const ::basic::Pubkey&
ConsumeEventsRequest::_Internal::pc_wallet(const ConsumeEventsRequest* msg) {
  return *msg->pc_wallet_;
}
void ConsumeEventsRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void ConsumeEventsRequest::clear_payer() {
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
}
void ConsumeEventsRequest::clear_coin_wallet() {
  if (GetArenaForAllocation() == nullptr && coin_wallet_ != nullptr) {
    delete coin_wallet_;
  }
  coin_wallet_ = nullptr;
}
void ConsumeEventsRequest::clear_pc_wallet() {
  if (GetArenaForAllocation() == nullptr && pc_wallet_ != nullptr) {
    delete pc_wallet_;
  }
  pc_wallet_ = nullptr;
}
ConsumeEventsRequest::ConsumeEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.ConsumeEventsRequest)
}
ConsumeEventsRequest::ConsumeEventsRequest(const ConsumeEventsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  log_directory_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    log_directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_log_directory().empty()) {
    log_directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_log_directory(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_payer()) {
    payer_ = new ::basic::Keypair(*from.payer_);
  } else {
    payer_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_coin_wallet()) {
    coin_wallet_ = new ::basic::Pubkey(*from.coin_wallet_);
  } else {
    coin_wallet_ = nullptr;
  }
  if (from._internal_has_pc_wallet()) {
    pc_wallet_ = new ::basic::Pubkey(*from.pc_wallet_);
  } else {
    pc_wallet_ = nullptr;
  }
  ::memcpy(&num_workers_, &from.num_workers_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_wait_for_events_delay_) -
    reinterpret_cast<char*>(&num_workers_)) + sizeof(max_wait_for_events_delay_));
  // @@protoc_insertion_point(copy_constructor:serum.ConsumeEventsRequest)
}

inline void ConsumeEventsRequest::SharedCtor() {
log_directory_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  log_directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_wait_for_events_delay_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(max_wait_for_events_delay_));
}

ConsumeEventsRequest::~ConsumeEventsRequest() {
  // @@protoc_insertion_point(destructor:serum.ConsumeEventsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConsumeEventsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  log_directory_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete payer_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete coin_wallet_;
  if (this != internal_default_instance()) delete pc_wallet_;
}

void ConsumeEventsRequest::ArenaDtor(void* object) {
  ConsumeEventsRequest* _this = reinterpret_cast< ConsumeEventsRequest* >(object);
  (void)_this;
}
void ConsumeEventsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConsumeEventsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConsumeEventsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.ConsumeEventsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  log_directory_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && coin_wallet_ != nullptr) {
    delete coin_wallet_;
  }
  coin_wallet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pc_wallet_ != nullptr) {
    delete pc_wallet_;
  }
  pc_wallet_ = nullptr;
  ::memset(&num_workers_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_wait_for_events_delay_) -
      reinterpret_cast<char*>(&num_workers_)) + sizeof(max_wait_for_events_delay_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsumeEventsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair payer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_payer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey coin_wallet = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey pc_wallet = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_pc_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 num_workers = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          num_workers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 events_per_worker = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          events_per_worker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 num_accounts = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          num_accounts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string log_directory = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_log_directory();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "serum.ConsumeEventsRequest.log_directory"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_q_length = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          max_q_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_wait_for_events_delay = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          max_wait_for_events_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConsumeEventsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.ConsumeEventsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Keypair payer = 2;
  if (this->_internal_has_payer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::payer(this), target, stream);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey coin_wallet = 4;
  if (this->_internal_has_coin_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::coin_wallet(this), target, stream);
  }

  // .basic.Pubkey pc_wallet = 5;
  if (this->_internal_has_pc_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::pc_wallet(this), target, stream);
  }

  // uint64 num_workers = 6;
  if (this->_internal_num_workers() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_num_workers(), target);
  }

  // uint64 events_per_worker = 7;
  if (this->_internal_events_per_worker() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_events_per_worker(), target);
  }

  // uint64 num_accounts = 8;
  if (this->_internal_num_accounts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_num_accounts(), target);
  }

  // string log_directory = 9;
  if (!this->_internal_log_directory().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_log_directory().data(), static_cast<int>(this->_internal_log_directory().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "serum.ConsumeEventsRequest.log_directory");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_log_directory(), target);
  }

  // uint64 max_q_length = 10;
  if (this->_internal_max_q_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_max_q_length(), target);
  }

  // uint64 max_wait_for_events_delay = 11;
  if (this->_internal_max_wait_for_events_delay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_max_wait_for_events_delay(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.ConsumeEventsRequest)
  return target;
}

size_t ConsumeEventsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.ConsumeEventsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string log_directory = 9;
  if (!this->_internal_log_directory().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_log_directory());
  }

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Keypair payer = 2;
  if (this->_internal_has_payer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *payer_);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey coin_wallet = 4;
  if (this->_internal_has_coin_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coin_wallet_);
  }

  // .basic.Pubkey pc_wallet = 5;
  if (this->_internal_has_pc_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pc_wallet_);
  }

  // uint64 num_workers = 6;
  if (this->_internal_num_workers() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_num_workers());
  }

  // uint64 events_per_worker = 7;
  if (this->_internal_events_per_worker() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_events_per_worker());
  }

  // uint64 num_accounts = 8;
  if (this->_internal_num_accounts() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_num_accounts());
  }

  // uint64 max_q_length = 10;
  if (this->_internal_max_q_length() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_q_length());
  }

  // uint64 max_wait_for_events_delay = 11;
  if (this->_internal_max_wait_for_events_delay() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_wait_for_events_delay());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsumeEventsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConsumeEventsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsumeEventsRequest::GetClassData() const { return &_class_data_; }

void ConsumeEventsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConsumeEventsRequest *>(to)->MergeFrom(
      static_cast<const ConsumeEventsRequest &>(from));
}


void ConsumeEventsRequest::MergeFrom(const ConsumeEventsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.ConsumeEventsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_log_directory().empty()) {
    _internal_set_log_directory(from._internal_log_directory());
  }
  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_payer()) {
    _internal_mutable_payer()->::basic::Keypair::MergeFrom(from._internal_payer());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_coin_wallet()) {
    _internal_mutable_coin_wallet()->::basic::Pubkey::MergeFrom(from._internal_coin_wallet());
  }
  if (from._internal_has_pc_wallet()) {
    _internal_mutable_pc_wallet()->::basic::Pubkey::MergeFrom(from._internal_pc_wallet());
  }
  if (from._internal_num_workers() != 0) {
    _internal_set_num_workers(from._internal_num_workers());
  }
  if (from._internal_events_per_worker() != 0) {
    _internal_set_events_per_worker(from._internal_events_per_worker());
  }
  if (from._internal_num_accounts() != 0) {
    _internal_set_num_accounts(from._internal_num_accounts());
  }
  if (from._internal_max_q_length() != 0) {
    _internal_set_max_q_length(from._internal_max_q_length());
  }
  if (from._internal_max_wait_for_events_delay() != 0) {
    _internal_set_max_wait_for_events_delay(from._internal_max_wait_for_events_delay());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsumeEventsRequest::CopyFrom(const ConsumeEventsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.ConsumeEventsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsumeEventsRequest::IsInitialized() const {
  return true;
}

void ConsumeEventsRequest::InternalSwap(ConsumeEventsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &log_directory_, lhs_arena,
      &other->log_directory_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConsumeEventsRequest, max_wait_for_events_delay_)
      + sizeof(ConsumeEventsRequest::max_wait_for_events_delay_)
      - PROTOBUF_FIELD_OFFSET(ConsumeEventsRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsumeEventsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[13]);
}

// ===================================================================

class MatchOrdersRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const MatchOrdersRequest* msg);
  static const ::basic::Keypair& payer(const MatchOrdersRequest* msg);
  static const ::serum::MarketState& market(const MatchOrdersRequest* msg);
  static const ::basic::Pubkey& coin_wallet(const MatchOrdersRequest* msg);
  static const ::basic::Pubkey& pc_wallet(const MatchOrdersRequest* msg);
};

const ::basic::ProgramId&
MatchOrdersRequest::_Internal::dex_program_id(const MatchOrdersRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Keypair&
MatchOrdersRequest::_Internal::payer(const MatchOrdersRequest* msg) {
  return *msg->payer_;
}
const ::serum::MarketState&
MatchOrdersRequest::_Internal::market(const MatchOrdersRequest* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
MatchOrdersRequest::_Internal::coin_wallet(const MatchOrdersRequest* msg) {
  return *msg->coin_wallet_;
}
const ::basic::Pubkey&
MatchOrdersRequest::_Internal::pc_wallet(const MatchOrdersRequest* msg) {
  return *msg->pc_wallet_;
}
void MatchOrdersRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void MatchOrdersRequest::clear_payer() {
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
}
void MatchOrdersRequest::clear_coin_wallet() {
  if (GetArenaForAllocation() == nullptr && coin_wallet_ != nullptr) {
    delete coin_wallet_;
  }
  coin_wallet_ = nullptr;
}
void MatchOrdersRequest::clear_pc_wallet() {
  if (GetArenaForAllocation() == nullptr && pc_wallet_ != nullptr) {
    delete pc_wallet_;
  }
  pc_wallet_ = nullptr;
}
MatchOrdersRequest::MatchOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.MatchOrdersRequest)
}
MatchOrdersRequest::MatchOrdersRequest(const MatchOrdersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_payer()) {
    payer_ = new ::basic::Keypair(*from.payer_);
  } else {
    payer_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_coin_wallet()) {
    coin_wallet_ = new ::basic::Pubkey(*from.coin_wallet_);
  } else {
    coin_wallet_ = nullptr;
  }
  if (from._internal_has_pc_wallet()) {
    pc_wallet_ = new ::basic::Pubkey(*from.pc_wallet_);
  } else {
    pc_wallet_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.MatchOrdersRequest)
}

inline void MatchOrdersRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pc_wallet_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(pc_wallet_));
}

MatchOrdersRequest::~MatchOrdersRequest() {
  // @@protoc_insertion_point(destructor:serum.MatchOrdersRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MatchOrdersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete payer_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete coin_wallet_;
  if (this != internal_default_instance()) delete pc_wallet_;
}

void MatchOrdersRequest::ArenaDtor(void* object) {
  MatchOrdersRequest* _this = reinterpret_cast< MatchOrdersRequest* >(object);
  (void)_this;
}
void MatchOrdersRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MatchOrdersRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatchOrdersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.MatchOrdersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && coin_wallet_ != nullptr) {
    delete coin_wallet_;
  }
  coin_wallet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pc_wallet_ != nullptr) {
    delete pc_wallet_;
  }
  pc_wallet_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MatchOrdersRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair payer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_payer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey coin_wallet = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey pc_wallet = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_pc_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchOrdersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.MatchOrdersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Keypair payer = 2;
  if (this->_internal_has_payer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::payer(this), target, stream);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey coin_wallet = 4;
  if (this->_internal_has_coin_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::coin_wallet(this), target, stream);
  }

  // .basic.Pubkey pc_wallet = 5;
  if (this->_internal_has_pc_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::pc_wallet(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.MatchOrdersRequest)
  return target;
}

size_t MatchOrdersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.MatchOrdersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Keypair payer = 2;
  if (this->_internal_has_payer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *payer_);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey coin_wallet = 4;
  if (this->_internal_has_coin_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coin_wallet_);
  }

  // .basic.Pubkey pc_wallet = 5;
  if (this->_internal_has_pc_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pc_wallet_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MatchOrdersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MatchOrdersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MatchOrdersRequest::GetClassData() const { return &_class_data_; }

void MatchOrdersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MatchOrdersRequest *>(to)->MergeFrom(
      static_cast<const MatchOrdersRequest &>(from));
}


void MatchOrdersRequest::MergeFrom(const MatchOrdersRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.MatchOrdersRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_payer()) {
    _internal_mutable_payer()->::basic::Keypair::MergeFrom(from._internal_payer());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_coin_wallet()) {
    _internal_mutable_coin_wallet()->::basic::Pubkey::MergeFrom(from._internal_coin_wallet());
  }
  if (from._internal_has_pc_wallet()) {
    _internal_mutable_pc_wallet()->::basic::Pubkey::MergeFrom(from._internal_pc_wallet());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MatchOrdersRequest::CopyFrom(const MatchOrdersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.MatchOrdersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchOrdersRequest::IsInitialized() const {
  return true;
}

void MatchOrdersRequest::InternalSwap(MatchOrdersRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchOrdersRequest, pc_wallet_)
      + sizeof(MatchOrdersRequest::pc_wallet_)
      - PROTOBUF_FIELD_OFFSET(MatchOrdersRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MatchOrdersRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[14]);
}

// ===================================================================

class MonitorQueueRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const MonitorQueueRequest* msg);
  static const ::serum::MarketState& market(const MonitorQueueRequest* msg);
};

const ::basic::ProgramId&
MonitorQueueRequest::_Internal::dex_program_id(const MonitorQueueRequest* msg) {
  return *msg->dex_program_id_;
}
const ::serum::MarketState&
MonitorQueueRequest::_Internal::market(const MonitorQueueRequest* msg) {
  return *msg->market_;
}
void MonitorQueueRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
MonitorQueueRequest::MonitorQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.MonitorQueueRequest)
}
MonitorQueueRequest::MonitorQueueRequest(const MonitorQueueRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:serum.MonitorQueueRequest)
}

inline void MonitorQueueRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&port_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(port_));
}

MonitorQueueRequest::~MonitorQueueRequest() {
  // @@protoc_insertion_point(destructor:serum.MonitorQueueRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MonitorQueueRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete market_;
}

void MonitorQueueRequest::ArenaDtor(void* object) {
  MonitorQueueRequest* _this = reinterpret_cast< MonitorQueueRequest* >(object);
  (void)_this;
}
void MonitorQueueRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MonitorQueueRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MonitorQueueRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.MonitorQueueRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  port_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonitorQueueRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonitorQueueRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.MonitorQueueRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .serum.MarketState market = 2;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::market(this), target, stream);
  }

  // uint32 port = 3;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.MonitorQueueRequest)
  return target;
}

size_t MonitorQueueRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.MonitorQueueRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .serum.MarketState market = 2;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // uint32 port = 3;
  if (this->_internal_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonitorQueueRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MonitorQueueRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonitorQueueRequest::GetClassData() const { return &_class_data_; }

void MonitorQueueRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MonitorQueueRequest *>(to)->MergeFrom(
      static_cast<const MonitorQueueRequest &>(from));
}


void MonitorQueueRequest::MergeFrom(const MonitorQueueRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.MonitorQueueRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_port() != 0) {
    _internal_set_port(from._internal_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonitorQueueRequest::CopyFrom(const MonitorQueueRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.MonitorQueueRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonitorQueueRequest::IsInitialized() const {
  return true;
}

void MonitorQueueRequest::InternalSwap(MonitorQueueRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonitorQueueRequest, port_)
      + sizeof(MonitorQueueRequest::port_)
      - PROTOBUF_FIELD_OFFSET(MonitorQueueRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MonitorQueueRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[15]);
}

// ===================================================================

class PrintEventQueue::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const PrintEventQueue* msg);
  static const ::basic::Pubkey& market(const PrintEventQueue* msg);
};

const ::basic::ProgramId&
PrintEventQueue::_Internal::dex_program_id(const PrintEventQueue* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Pubkey&
PrintEventQueue::_Internal::market(const PrintEventQueue* msg) {
  return *msg->market_;
}
void PrintEventQueue::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void PrintEventQueue::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
PrintEventQueue::PrintEventQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.PrintEventQueue)
}
PrintEventQueue::PrintEventQueue(const PrintEventQueue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::basic::Pubkey(*from.market_);
  } else {
    market_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.PrintEventQueue)
}

inline void PrintEventQueue::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&market_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(market_));
}

PrintEventQueue::~PrintEventQueue() {
  // @@protoc_insertion_point(destructor:serum.PrintEventQueue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PrintEventQueue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete market_;
}

void PrintEventQueue::ArenaDtor(void* object) {
  PrintEventQueue* _this = reinterpret_cast< PrintEventQueue* >(object);
  (void)_this;
}
void PrintEventQueue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrintEventQueue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PrintEventQueue::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.PrintEventQueue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrintEventQueue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey market = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrintEventQueue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.PrintEventQueue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Pubkey market = 2;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::market(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.PrintEventQueue)
  return target;
}

size_t PrintEventQueue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.PrintEventQueue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Pubkey market = 2;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrintEventQueue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PrintEventQueue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrintEventQueue::GetClassData() const { return &_class_data_; }

void PrintEventQueue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PrintEventQueue *>(to)->MergeFrom(
      static_cast<const PrintEventQueue &>(from));
}


void PrintEventQueue::MergeFrom(const PrintEventQueue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.PrintEventQueue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::basic::Pubkey::MergeFrom(from._internal_market());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrintEventQueue::CopyFrom(const PrintEventQueue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.PrintEventQueue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrintEventQueue::IsInitialized() const {
  return true;
}

void PrintEventQueue::InternalSwap(PrintEventQueue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrintEventQueue, market_)
      + sizeof(PrintEventQueue::market_)
      - PROTOBUF_FIELD_OFFSET(PrintEventQueue, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PrintEventQueue::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[16]);
}

// ===================================================================

class WholeShebang::_Internal {
 public:
  static const ::basic::Keypair& payer(const WholeShebang* msg);
  static const ::basic::ProgramId& dex_program_id(const WholeShebang* msg);
};

const ::basic::Keypair&
WholeShebang::_Internal::payer(const WholeShebang* msg) {
  return *msg->payer_;
}
const ::basic::ProgramId&
WholeShebang::_Internal::dex_program_id(const WholeShebang* msg) {
  return *msg->dex_program_id_;
}
void WholeShebang::clear_payer() {
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
}
void WholeShebang::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
WholeShebang::WholeShebang(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.WholeShebang)
}
WholeShebang::WholeShebang(const WholeShebang& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_payer()) {
    payer_ = new ::basic::Keypair(*from.payer_);
  } else {
    payer_ = nullptr;
  }
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.WholeShebang)
}

inline void WholeShebang::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&payer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dex_program_id_) -
    reinterpret_cast<char*>(&payer_)) + sizeof(dex_program_id_));
}

WholeShebang::~WholeShebang() {
  // @@protoc_insertion_point(destructor:serum.WholeShebang)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WholeShebang::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete payer_;
  if (this != internal_default_instance()) delete dex_program_id_;
}

void WholeShebang::ArenaDtor(void* object) {
  WholeShebang* _this = reinterpret_cast< WholeShebang* >(object);
  (void)_this;
}
void WholeShebang::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WholeShebang::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WholeShebang::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.WholeShebang)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WholeShebang::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.Keypair payer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_payer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.ProgramId dex_program_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WholeShebang::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.WholeShebang)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.Keypair payer = 1;
  if (this->_internal_has_payer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::payer(this), target, stream);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dex_program_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.WholeShebang)
  return target;
}

size_t WholeShebang::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.WholeShebang)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.Keypair payer = 1;
  if (this->_internal_has_payer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *payer_);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WholeShebang::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    WholeShebang::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WholeShebang::GetClassData() const { return &_class_data_; }

void WholeShebang::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<WholeShebang *>(to)->MergeFrom(
      static_cast<const WholeShebang &>(from));
}


void WholeShebang::MergeFrom(const WholeShebang& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.WholeShebang)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_payer()) {
    _internal_mutable_payer()->::basic::Keypair::MergeFrom(from._internal_payer());
  }
  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WholeShebang::CopyFrom(const WholeShebang& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.WholeShebang)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WholeShebang::IsInitialized() const {
  return true;
}

void WholeShebang::InternalSwap(WholeShebang* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WholeShebang, dex_program_id_)
      + sizeof(WholeShebang::dex_program_id_)
      - PROTOBUF_FIELD_OFFSET(WholeShebang, payer_)>(
          reinterpret_cast<char*>(&payer_),
          reinterpret_cast<char*>(&other->payer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WholeShebang::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[17]);
}

// ===================================================================

class SettleFundsRequest::_Internal {
 public:
  static const ::basic::Keypair& payer(const SettleFundsRequest* msg);
  static const ::basic::ProgramId& dex_program_id(const SettleFundsRequest* msg);
  static const ::serum::MarketState& market(const SettleFundsRequest* msg);
  static const ::basic::Pubkey& orders(const SettleFundsRequest* msg);
  static const ::basic::Pubkey& coin_wallet(const SettleFundsRequest* msg);
  static const ::basic::Pubkey& pc_wallet(const SettleFundsRequest* msg);
  static const ::basic::Keypair& signer(const SettleFundsRequest* msg);
};

const ::basic::Keypair&
SettleFundsRequest::_Internal::payer(const SettleFundsRequest* msg) {
  return *msg->payer_;
}
const ::basic::ProgramId&
SettleFundsRequest::_Internal::dex_program_id(const SettleFundsRequest* msg) {
  return *msg->dex_program_id_;
}
const ::serum::MarketState&
SettleFundsRequest::_Internal::market(const SettleFundsRequest* msg) {
  return *msg->market_;
}
const ::basic::Pubkey&
SettleFundsRequest::_Internal::orders(const SettleFundsRequest* msg) {
  return *msg->orders_;
}
const ::basic::Pubkey&
SettleFundsRequest::_Internal::coin_wallet(const SettleFundsRequest* msg) {
  return *msg->coin_wallet_;
}
const ::basic::Pubkey&
SettleFundsRequest::_Internal::pc_wallet(const SettleFundsRequest* msg) {
  return *msg->pc_wallet_;
}
const ::basic::Keypair&
SettleFundsRequest::_Internal::signer(const SettleFundsRequest* msg) {
  return *msg->signer_;
}
void SettleFundsRequest::clear_payer() {
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
}
void SettleFundsRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void SettleFundsRequest::clear_orders() {
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
}
void SettleFundsRequest::clear_coin_wallet() {
  if (GetArenaForAllocation() == nullptr && coin_wallet_ != nullptr) {
    delete coin_wallet_;
  }
  coin_wallet_ = nullptr;
}
void SettleFundsRequest::clear_pc_wallet() {
  if (GetArenaForAllocation() == nullptr && pc_wallet_ != nullptr) {
    delete pc_wallet_;
  }
  pc_wallet_ = nullptr;
}
void SettleFundsRequest::clear_signer() {
  if (GetArenaForAllocation() == nullptr && signer_ != nullptr) {
    delete signer_;
  }
  signer_ = nullptr;
}
SettleFundsRequest::SettleFundsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.SettleFundsRequest)
}
SettleFundsRequest::SettleFundsRequest(const SettleFundsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_payer()) {
    payer_ = new ::basic::Keypair(*from.payer_);
  } else {
    payer_ = nullptr;
  }
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::serum::MarketState(*from.market_);
  } else {
    market_ = nullptr;
  }
  if (from._internal_has_orders()) {
    orders_ = new ::basic::Pubkey(*from.orders_);
  } else {
    orders_ = nullptr;
  }
  if (from._internal_has_coin_wallet()) {
    coin_wallet_ = new ::basic::Pubkey(*from.coin_wallet_);
  } else {
    coin_wallet_ = nullptr;
  }
  if (from._internal_has_pc_wallet()) {
    pc_wallet_ = new ::basic::Pubkey(*from.pc_wallet_);
  } else {
    pc_wallet_ = nullptr;
  }
  if (from._internal_has_signer()) {
    signer_ = new ::basic::Keypair(*from.signer_);
  } else {
    signer_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.SettleFundsRequest)
}

inline void SettleFundsRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&payer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&signer_) -
    reinterpret_cast<char*>(&payer_)) + sizeof(signer_));
}

SettleFundsRequest::~SettleFundsRequest() {
  // @@protoc_insertion_point(destructor:serum.SettleFundsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SettleFundsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete payer_;
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete market_;
  if (this != internal_default_instance()) delete orders_;
  if (this != internal_default_instance()) delete coin_wallet_;
  if (this != internal_default_instance()) delete pc_wallet_;
  if (this != internal_default_instance()) delete signer_;
}

void SettleFundsRequest::ArenaDtor(void* object) {
  SettleFundsRequest* _this = reinterpret_cast< SettleFundsRequest* >(object);
  (void)_this;
}
void SettleFundsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SettleFundsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SettleFundsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.SettleFundsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  if (GetArenaForAllocation() == nullptr && orders_ != nullptr) {
    delete orders_;
  }
  orders_ = nullptr;
  if (GetArenaForAllocation() == nullptr && coin_wallet_ != nullptr) {
    delete coin_wallet_;
  }
  coin_wallet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pc_wallet_ != nullptr) {
    delete pc_wallet_;
  }
  pc_wallet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && signer_ != nullptr) {
    delete signer_;
  }
  signer_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SettleFundsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.Keypair payer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_payer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.ProgramId dex_program_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .serum.MarketState market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey orders = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_orders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey coin_wallet = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey pc_wallet = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pc_wallet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Keypair signer = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_signer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SettleFundsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.SettleFundsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.Keypair payer = 1;
  if (this->_internal_has_payer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::payer(this), target, stream);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dex_program_id(this), target, stream);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::market(this), target, stream);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::orders(this), target, stream);
  }

  // .basic.Pubkey coin_wallet = 5;
  if (this->_internal_has_coin_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::coin_wallet(this), target, stream);
  }

  // .basic.Pubkey pc_wallet = 6;
  if (this->_internal_has_pc_wallet()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::pc_wallet(this), target, stream);
  }

  // .basic.Keypair signer = 7;
  if (this->_internal_has_signer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::signer(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.SettleFundsRequest)
  return target;
}

size_t SettleFundsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.SettleFundsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.Keypair payer = 1;
  if (this->_internal_has_payer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *payer_);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .serum.MarketState market = 3;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  // .basic.Pubkey orders = 4;
  if (this->_internal_has_orders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orders_);
  }

  // .basic.Pubkey coin_wallet = 5;
  if (this->_internal_has_coin_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coin_wallet_);
  }

  // .basic.Pubkey pc_wallet = 6;
  if (this->_internal_has_pc_wallet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pc_wallet_);
  }

  // .basic.Keypair signer = 7;
  if (this->_internal_has_signer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *signer_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SettleFundsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SettleFundsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SettleFundsRequest::GetClassData() const { return &_class_data_; }

void SettleFundsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SettleFundsRequest *>(to)->MergeFrom(
      static_cast<const SettleFundsRequest &>(from));
}


void SettleFundsRequest::MergeFrom(const SettleFundsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.SettleFundsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_payer()) {
    _internal_mutable_payer()->::basic::Keypair::MergeFrom(from._internal_payer());
  }
  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::serum::MarketState::MergeFrom(from._internal_market());
  }
  if (from._internal_has_orders()) {
    _internal_mutable_orders()->::basic::Pubkey::MergeFrom(from._internal_orders());
  }
  if (from._internal_has_coin_wallet()) {
    _internal_mutable_coin_wallet()->::basic::Pubkey::MergeFrom(from._internal_coin_wallet());
  }
  if (from._internal_has_pc_wallet()) {
    _internal_mutable_pc_wallet()->::basic::Pubkey::MergeFrom(from._internal_pc_wallet());
  }
  if (from._internal_has_signer()) {
    _internal_mutable_signer()->::basic::Keypair::MergeFrom(from._internal_signer());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SettleFundsRequest::CopyFrom(const SettleFundsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.SettleFundsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SettleFundsRequest::IsInitialized() const {
  return true;
}

void SettleFundsRequest::InternalSwap(SettleFundsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SettleFundsRequest, signer_)
      + sizeof(SettleFundsRequest::signer_)
      - PROTOBUF_FIELD_OFFSET(SettleFundsRequest, payer_)>(
          reinterpret_cast<char*>(&payer_),
          reinterpret_cast<char*>(&other->payer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SettleFundsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[18]);
}

// ===================================================================

class ListMarketRequest::_Internal {
 public:
  static const ::basic::Keypair& payer(const ListMarketRequest* msg);
  static const ::basic::ProgramId& dex_program_id(const ListMarketRequest* msg);
  static const ::basic::Pubkey& coin_mint(const ListMarketRequest* msg);
  static const ::basic::Pubkey& pc_mint(const ListMarketRequest* msg);
};

const ::basic::Keypair&
ListMarketRequest::_Internal::payer(const ListMarketRequest* msg) {
  return *msg->payer_;
}
const ::basic::ProgramId&
ListMarketRequest::_Internal::dex_program_id(const ListMarketRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Pubkey&
ListMarketRequest::_Internal::coin_mint(const ListMarketRequest* msg) {
  return *msg->coin_mint_;
}
const ::basic::Pubkey&
ListMarketRequest::_Internal::pc_mint(const ListMarketRequest* msg) {
  return *msg->pc_mint_;
}
void ListMarketRequest::clear_payer() {
  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
}
void ListMarketRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void ListMarketRequest::clear_coin_mint() {
  if (GetArenaForAllocation() == nullptr && coin_mint_ != nullptr) {
    delete coin_mint_;
  }
  coin_mint_ = nullptr;
}
void ListMarketRequest::clear_pc_mint() {
  if (GetArenaForAllocation() == nullptr && pc_mint_ != nullptr) {
    delete pc_mint_;
  }
  pc_mint_ = nullptr;
}
ListMarketRequest::ListMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.ListMarketRequest)
}
ListMarketRequest::ListMarketRequest(const ListMarketRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_payer()) {
    payer_ = new ::basic::Keypair(*from.payer_);
  } else {
    payer_ = nullptr;
  }
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_coin_mint()) {
    coin_mint_ = new ::basic::Pubkey(*from.coin_mint_);
  } else {
    coin_mint_ = nullptr;
  }
  if (from._internal_has_pc_mint()) {
    pc_mint_ = new ::basic::Pubkey(*from.pc_mint_);
  } else {
    pc_mint_ = nullptr;
  }
  ::memcpy(&coin_lot_size_, &from.coin_lot_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&pc_lot_size_) -
    reinterpret_cast<char*>(&coin_lot_size_)) + sizeof(pc_lot_size_));
  // @@protoc_insertion_point(copy_constructor:serum.ListMarketRequest)
}

inline void ListMarketRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&payer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pc_lot_size_) -
    reinterpret_cast<char*>(&payer_)) + sizeof(pc_lot_size_));
}

ListMarketRequest::~ListMarketRequest() {
  // @@protoc_insertion_point(destructor:serum.ListMarketRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListMarketRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete payer_;
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete coin_mint_;
  if (this != internal_default_instance()) delete pc_mint_;
}

void ListMarketRequest::ArenaDtor(void* object) {
  ListMarketRequest* _this = reinterpret_cast< ListMarketRequest* >(object);
  (void)_this;
}
void ListMarketRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListMarketRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListMarketRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.ListMarketRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && payer_ != nullptr) {
    delete payer_;
  }
  payer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && coin_mint_ != nullptr) {
    delete coin_mint_;
  }
  coin_mint_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pc_mint_ != nullptr) {
    delete pc_mint_;
  }
  pc_mint_ = nullptr;
  ::memset(&coin_lot_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pc_lot_size_) -
      reinterpret_cast<char*>(&coin_lot_size_)) + sizeof(pc_lot_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListMarketRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.Keypair payer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_payer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.ProgramId dex_program_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey coin_mint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_mint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey pc_mint = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pc_mint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 coin_lot_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          coin_lot_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 pc_lot_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          pc_lot_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListMarketRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.ListMarketRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.Keypair payer = 1;
  if (this->_internal_has_payer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::payer(this), target, stream);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Pubkey coin_mint = 3;
  if (this->_internal_has_coin_mint()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::coin_mint(this), target, stream);
  }

  // .basic.Pubkey pc_mint = 4;
  if (this->_internal_has_pc_mint()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::pc_mint(this), target, stream);
  }

  // uint64 coin_lot_size = 5;
  if (this->_internal_coin_lot_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_coin_lot_size(), target);
  }

  // uint64 pc_lot_size = 6;
  if (this->_internal_pc_lot_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_pc_lot_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.ListMarketRequest)
  return target;
}

size_t ListMarketRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.ListMarketRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.Keypair payer = 1;
  if (this->_internal_has_payer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *payer_);
  }

  // .basic.ProgramId dex_program_id = 2;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Pubkey coin_mint = 3;
  if (this->_internal_has_coin_mint()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coin_mint_);
  }

  // .basic.Pubkey pc_mint = 4;
  if (this->_internal_has_pc_mint()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pc_mint_);
  }

  // uint64 coin_lot_size = 5;
  if (this->_internal_coin_lot_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_coin_lot_size());
  }

  // uint64 pc_lot_size = 6;
  if (this->_internal_pc_lot_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_pc_lot_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListMarketRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListMarketRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListMarketRequest::GetClassData() const { return &_class_data_; }

void ListMarketRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListMarketRequest *>(to)->MergeFrom(
      static_cast<const ListMarketRequest &>(from));
}


void ListMarketRequest::MergeFrom(const ListMarketRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.ListMarketRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_payer()) {
    _internal_mutable_payer()->::basic::Keypair::MergeFrom(from._internal_payer());
  }
  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_coin_mint()) {
    _internal_mutable_coin_mint()->::basic::Pubkey::MergeFrom(from._internal_coin_mint());
  }
  if (from._internal_has_pc_mint()) {
    _internal_mutable_pc_mint()->::basic::Pubkey::MergeFrom(from._internal_pc_mint());
  }
  if (from._internal_coin_lot_size() != 0) {
    _internal_set_coin_lot_size(from._internal_coin_lot_size());
  }
  if (from._internal_pc_lot_size() != 0) {
    _internal_set_pc_lot_size(from._internal_pc_lot_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListMarketRequest::CopyFrom(const ListMarketRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.ListMarketRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListMarketRequest::IsInitialized() const {
  return true;
}

void ListMarketRequest::InternalSwap(ListMarketRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListMarketRequest, pc_lot_size_)
      + sizeof(ListMarketRequest::pc_lot_size_)
      - PROTOBUF_FIELD_OFFSET(ListMarketRequest, payer_)>(
          reinterpret_cast<char*>(&payer_),
          reinterpret_cast<char*>(&other->payer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListMarketRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[19]);
}

// ===================================================================

class InitializeTokenAccount::_Internal {
 public:
  static const ::basic::Pubkey& mint(const InitializeTokenAccount* msg);
  static const ::basic::Pubkey& owner_account(const InitializeTokenAccount* msg);
};

const ::basic::Pubkey&
InitializeTokenAccount::_Internal::mint(const InitializeTokenAccount* msg) {
  return *msg->mint_;
}
const ::basic::Pubkey&
InitializeTokenAccount::_Internal::owner_account(const InitializeTokenAccount* msg) {
  return *msg->owner_account_;
}
void InitializeTokenAccount::clear_mint() {
  if (GetArenaForAllocation() == nullptr && mint_ != nullptr) {
    delete mint_;
  }
  mint_ = nullptr;
}
void InitializeTokenAccount::clear_owner_account() {
  if (GetArenaForAllocation() == nullptr && owner_account_ != nullptr) {
    delete owner_account_;
  }
  owner_account_ = nullptr;
}
InitializeTokenAccount::InitializeTokenAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.InitializeTokenAccount)
}
InitializeTokenAccount::InitializeTokenAccount(const InitializeTokenAccount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mint()) {
    mint_ = new ::basic::Pubkey(*from.mint_);
  } else {
    mint_ = nullptr;
  }
  if (from._internal_has_owner_account()) {
    owner_account_ = new ::basic::Pubkey(*from.owner_account_);
  } else {
    owner_account_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.InitializeTokenAccount)
}

inline void InitializeTokenAccount::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mint_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&owner_account_) -
    reinterpret_cast<char*>(&mint_)) + sizeof(owner_account_));
}

InitializeTokenAccount::~InitializeTokenAccount() {
  // @@protoc_insertion_point(destructor:serum.InitializeTokenAccount)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void InitializeTokenAccount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete mint_;
  if (this != internal_default_instance()) delete owner_account_;
}

void InitializeTokenAccount::ArenaDtor(void* object) {
  InitializeTokenAccount* _this = reinterpret_cast< InitializeTokenAccount* >(object);
  (void)_this;
}
void InitializeTokenAccount::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitializeTokenAccount::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitializeTokenAccount::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.InitializeTokenAccount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && mint_ != nullptr) {
    delete mint_;
  }
  mint_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_account_ != nullptr) {
    delete owner_account_;
  }
  owner_account_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitializeTokenAccount::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.Pubkey mint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey owner_account = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_account(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitializeTokenAccount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.InitializeTokenAccount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.Pubkey mint = 1;
  if (this->_internal_has_mint()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::mint(this), target, stream);
  }

  // .basic.Pubkey owner_account = 2;
  if (this->_internal_has_owner_account()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner_account(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.InitializeTokenAccount)
  return target;
}

size_t InitializeTokenAccount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.InitializeTokenAccount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.Pubkey mint = 1;
  if (this->_internal_has_mint()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mint_);
  }

  // .basic.Pubkey owner_account = 2;
  if (this->_internal_has_owner_account()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_account_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitializeTokenAccount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InitializeTokenAccount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitializeTokenAccount::GetClassData() const { return &_class_data_; }

void InitializeTokenAccount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InitializeTokenAccount *>(to)->MergeFrom(
      static_cast<const InitializeTokenAccount &>(from));
}


void InitializeTokenAccount::MergeFrom(const InitializeTokenAccount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.InitializeTokenAccount)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mint()) {
    _internal_mutable_mint()->::basic::Pubkey::MergeFrom(from._internal_mint());
  }
  if (from._internal_has_owner_account()) {
    _internal_mutable_owner_account()->::basic::Pubkey::MergeFrom(from._internal_owner_account());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InitializeTokenAccount::CopyFrom(const InitializeTokenAccount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.InitializeTokenAccount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitializeTokenAccount::IsInitialized() const {
  return true;
}

void InitializeTokenAccount::InternalSwap(InitializeTokenAccount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitializeTokenAccount, owner_account_)
      + sizeof(InitializeTokenAccount::owner_account_)
      - PROTOBUF_FIELD_OFFSET(InitializeTokenAccount, mint_)>(
          reinterpret_cast<char*>(&mint_),
          reinterpret_cast<char*>(&other->mint_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InitializeTokenAccount::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[20]);
}

// ===================================================================

class MarketRequest::_Internal {
 public:
  static const ::basic::ProgramId& dex_program_id(const MarketRequest* msg);
  static const ::basic::Pubkey& market(const MarketRequest* msg);
};

const ::basic::ProgramId&
MarketRequest::_Internal::dex_program_id(const MarketRequest* msg) {
  return *msg->dex_program_id_;
}
const ::basic::Pubkey&
MarketRequest::_Internal::market(const MarketRequest* msg) {
  return *msg->market_;
}
void MarketRequest::clear_dex_program_id() {
  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
}
void MarketRequest::clear_market() {
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
}
MarketRequest::MarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:serum.MarketRequest)
}
MarketRequest::MarketRequest(const MarketRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dex_program_id()) {
    dex_program_id_ = new ::basic::ProgramId(*from.dex_program_id_);
  } else {
    dex_program_id_ = nullptr;
  }
  if (from._internal_has_market()) {
    market_ = new ::basic::Pubkey(*from.market_);
  } else {
    market_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:serum.MarketRequest)
}

inline void MarketRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dex_program_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&market_) -
    reinterpret_cast<char*>(&dex_program_id_)) + sizeof(market_));
}

MarketRequest::~MarketRequest() {
  // @@protoc_insertion_point(destructor:serum.MarketRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MarketRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dex_program_id_;
  if (this != internal_default_instance()) delete market_;
}

void MarketRequest::ArenaDtor(void* object) {
  MarketRequest* _this = reinterpret_cast< MarketRequest* >(object);
  (void)_this;
}
void MarketRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MarketRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MarketRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:serum.MarketRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && dex_program_id_ != nullptr) {
    delete dex_program_id_;
  }
  dex_program_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && market_ != nullptr) {
    delete market_;
  }
  market_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .basic.ProgramId dex_program_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dex_program_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .basic.Pubkey market = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarketRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:serum.MarketRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::dex_program_id(this), target, stream);
  }

  // .basic.Pubkey market = 2;
  if (this->_internal_has_market()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::market(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:serum.MarketRequest)
  return target;
}

size_t MarketRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:serum.MarketRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .basic.ProgramId dex_program_id = 1;
  if (this->_internal_has_dex_program_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dex_program_id_);
  }

  // .basic.Pubkey market = 2;
  if (this->_internal_has_market()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *market_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MarketRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketRequest::GetClassData() const { return &_class_data_; }

void MarketRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MarketRequest *>(to)->MergeFrom(
      static_cast<const MarketRequest &>(from));
}


void MarketRequest::MergeFrom(const MarketRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:serum.MarketRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dex_program_id()) {
    _internal_mutable_dex_program_id()->::basic::ProgramId::MergeFrom(from._internal_dex_program_id());
  }
  if (from._internal_has_market()) {
    _internal_mutable_market()->::basic::Pubkey::MergeFrom(from._internal_market());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketRequest::CopyFrom(const MarketRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:serum.MarketRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketRequest::IsInitialized() const {
  return true;
}

void MarketRequest::InternalSwap(MarketRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarketRequest, market_)
      + sizeof(MarketRequest::market_)
      - PROTOBUF_FIELD_OFFSET(MarketRequest, dex_program_id_)>(
          reinterpret_cast<char*>(&dex_program_id_),
          reinterpret_cast<char*>(&other->dex_program_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fserum_2eproto_getter, &descriptor_table_proto_2fserum_2eproto_once,
      file_level_metadata_proto_2fserum_2eproto[21]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace serum
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::serum::MarketState* Arena::CreateMaybeMessage< ::serum::MarketState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::MarketState >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::InitOpenOrderRequest* Arena::CreateMaybeMessage< ::serum::InitOpenOrderRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::InitOpenOrderRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::CloseOpenOrderRequest* Arena::CreateMaybeMessage< ::serum::CloseOpenOrderRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::CloseOpenOrderRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::CancelOrderRequest* Arena::CreateMaybeMessage< ::serum::CancelOrderRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::CancelOrderRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::ListMarketResponse* Arena::CreateMaybeMessage< ::serum::ListMarketResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::ListMarketResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::Order* Arena::CreateMaybeMessage< ::serum::Order >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::Order >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::OrderStatus* Arena::CreateMaybeMessage< ::serum::OrderStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::OrderStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::NewOrderInstructionV3* Arena::CreateMaybeMessage< ::serum::NewOrderInstructionV3 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::NewOrderInstructionV3 >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::Event* Arena::CreateMaybeMessage< ::serum::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::Bid* Arena::CreateMaybeMessage< ::serum::Bid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::Bid >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::Ask* Arena::CreateMaybeMessage< ::serum::Ask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::Ask >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::ConsumeEventUpdate* Arena::CreateMaybeMessage< ::serum::ConsumeEventUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::ConsumeEventUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::MarketPubkeys* Arena::CreateMaybeMessage< ::serum::MarketPubkeys >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::MarketPubkeys >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::ConsumeEventsRequest* Arena::CreateMaybeMessage< ::serum::ConsumeEventsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::ConsumeEventsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::MatchOrdersRequest* Arena::CreateMaybeMessage< ::serum::MatchOrdersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::MatchOrdersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::MonitorQueueRequest* Arena::CreateMaybeMessage< ::serum::MonitorQueueRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::MonitorQueueRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::PrintEventQueue* Arena::CreateMaybeMessage< ::serum::PrintEventQueue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::PrintEventQueue >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::WholeShebang* Arena::CreateMaybeMessage< ::serum::WholeShebang >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::WholeShebang >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::SettleFundsRequest* Arena::CreateMaybeMessage< ::serum::SettleFundsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::SettleFundsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::ListMarketRequest* Arena::CreateMaybeMessage< ::serum::ListMarketRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::ListMarketRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::InitializeTokenAccount* Arena::CreateMaybeMessage< ::serum::InitializeTokenAccount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::InitializeTokenAccount >(arena);
}
template<> PROTOBUF_NOINLINE ::serum::MarketRequest* Arena::CreateMaybeMessage< ::serum::MarketRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::serum::MarketRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

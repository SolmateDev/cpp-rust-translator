// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/basic.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fbasic_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fbasic_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fbasic_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fbasic_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fbasic_2eproto;
namespace basic {
class AccountInfo;
struct AccountInfoDefaultTypeInternal;
extern AccountInfoDefaultTypeInternal _AccountInfo_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Keypair;
struct KeypairDefaultTypeInternal;
extern KeypairDefaultTypeInternal _Keypair_default_instance_;
class ProgramId;
struct ProgramIdDefaultTypeInternal;
extern ProgramIdDefaultTypeInternal _ProgramId_default_instance_;
class Pubkey;
struct PubkeyDefaultTypeInternal;
extern PubkeyDefaultTypeInternal _Pubkey_default_instance_;
class SignedTx;
struct SignedTxDefaultTypeInternal;
extern SignedTxDefaultTypeInternal _SignedTx_default_instance_;
class TxStatusWithSlot;
struct TxStatusWithSlotDefaultTypeInternal;
extern TxStatusWithSlotDefaultTypeInternal _TxStatusWithSlot_default_instance_;
}  // namespace basic
PROTOBUF_NAMESPACE_OPEN
template<> ::basic::AccountInfo* Arena::CreateMaybeMessage<::basic::AccountInfo>(Arena*);
template<> ::basic::Empty* Arena::CreateMaybeMessage<::basic::Empty>(Arena*);
template<> ::basic::Keypair* Arena::CreateMaybeMessage<::basic::Keypair>(Arena*);
template<> ::basic::ProgramId* Arena::CreateMaybeMessage<::basic::ProgramId>(Arena*);
template<> ::basic::Pubkey* Arena::CreateMaybeMessage<::basic::Pubkey>(Arena*);
template<> ::basic::SignedTx* Arena::CreateMaybeMessage<::basic::SignedTx>(Arena*);
template<> ::basic::TxStatusWithSlot* Arena::CreateMaybeMessage<::basic::TxStatusWithSlot>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace basic {

enum TxStatus : int {
  PROCESSED = 0,
  CONFIRMED = 1,
  FINALIZED = 2,
  TxStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TxStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TxStatus_IsValid(int value);
constexpr TxStatus TxStatus_MIN = PROCESSED;
constexpr TxStatus TxStatus_MAX = FINALIZED;
constexpr int TxStatus_ARRAYSIZE = TxStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxStatus_descriptor();
template<typename T>
inline const std::string& TxStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TxStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TxStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TxStatus_descriptor(), enum_t_value);
}
inline bool TxStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TxStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TxStatus>(
    TxStatus_descriptor(), name, value);
}
// ===================================================================

class AccountInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:basic.AccountInfo) */ {
 public:
  inline AccountInfo() : AccountInfo(nullptr) {}
  ~AccountInfo() override;
  explicit constexpr AccountInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountInfo(const AccountInfo& from);
  AccountInfo(AccountInfo&& from) noexcept
    : AccountInfo() {
    *this = ::std::move(from);
  }

  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountInfo& operator=(AccountInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountInfo* internal_default_instance() {
    return reinterpret_cast<const AccountInfo*>(
               &_AccountInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AccountInfo& a, AccountInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.AccountInfo";
  }
  protected:
  explicit AccountInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kSlotFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 slot = 1;
  void clear_slot();
  uint64_t slot() const;
  void set_slot(uint64_t value);
  private:
  uint64_t _internal_slot() const;
  void _internal_set_slot(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:basic.AccountInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  uint64_t slot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// -------------------------------------------------------------------

class SignedTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:basic.SignedTx) */ {
 public:
  inline SignedTx() : SignedTx(nullptr) {}
  ~SignedTx() override;
  explicit constexpr SignedTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedTx(const SignedTx& from);
  SignedTx(SignedTx&& from) noexcept
    : SignedTx() {
    *this = ::std::move(from);
  }

  inline SignedTx& operator=(const SignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedTx& operator=(SignedTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedTx* internal_default_instance() {
    return reinterpret_cast<const SignedTx*>(
               &_SignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignedTx& a, SignedTx& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignedTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.SignedTx";
  }
  protected:
  explicit SignedTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
  };
  // bytes tx = 1;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // @@protoc_insertion_point(class_scope:basic.SignedTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// -------------------------------------------------------------------

class TxStatusWithSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:basic.TxStatusWithSlot) */ {
 public:
  inline TxStatusWithSlot() : TxStatusWithSlot(nullptr) {}
  ~TxStatusWithSlot() override;
  explicit constexpr TxStatusWithSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxStatusWithSlot(const TxStatusWithSlot& from);
  TxStatusWithSlot(TxStatusWithSlot&& from) noexcept
    : TxStatusWithSlot() {
    *this = ::std::move(from);
  }

  inline TxStatusWithSlot& operator=(const TxStatusWithSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxStatusWithSlot& operator=(TxStatusWithSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxStatusWithSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxStatusWithSlot* internal_default_instance() {
    return reinterpret_cast<const TxStatusWithSlot*>(
               &_TxStatusWithSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TxStatusWithSlot& a, TxStatusWithSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(TxStatusWithSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxStatusWithSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxStatusWithSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxStatusWithSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxStatusWithSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxStatusWithSlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxStatusWithSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.TxStatusWithSlot";
  }
  protected:
  explicit TxStatusWithSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // uint64 slot = 2;
  void clear_slot();
  uint64_t slot() const;
  void set_slot(uint64_t value);
  private:
  uint64_t _internal_slot() const;
  void _internal_set_slot(uint64_t value);
  public:

  // .basic.TxStatus status = 1;
  void clear_status();
  ::basic::TxStatus status() const;
  void set_status(::basic::TxStatus value);
  private:
  ::basic::TxStatus _internal_status() const;
  void _internal_set_status(::basic::TxStatus value);
  public:

  // @@protoc_insertion_point(class_scope:basic.TxStatusWithSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t slot_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:basic.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:basic.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// -------------------------------------------------------------------

class Pubkey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:basic.Pubkey) */ {
 public:
  inline Pubkey() : Pubkey(nullptr) {}
  ~Pubkey() override;
  explicit constexpr Pubkey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pubkey(const Pubkey& from);
  Pubkey(Pubkey&& from) noexcept
    : Pubkey() {
    *this = ::std::move(from);
  }

  inline Pubkey& operator=(const Pubkey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pubkey& operator=(Pubkey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pubkey& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pubkey* internal_default_instance() {
    return reinterpret_cast<const Pubkey*>(
               &_Pubkey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Pubkey& a, Pubkey& b) {
    a.Swap(&b);
  }
  inline void Swap(Pubkey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pubkey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pubkey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pubkey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pubkey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pubkey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pubkey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.Pubkey";
  }
  protected:
  explicit Pubkey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:basic.Pubkey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// -------------------------------------------------------------------

class Keypair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:basic.Keypair) */ {
 public:
  inline Keypair() : Keypair(nullptr) {}
  ~Keypair() override;
  explicit constexpr Keypair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Keypair(const Keypair& from);
  Keypair(Keypair&& from) noexcept
    : Keypair() {
    *this = ::std::move(from);
  }

  inline Keypair& operator=(const Keypair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Keypair& operator=(Keypair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Keypair& default_instance() {
    return *internal_default_instance();
  }
  enum InputCase {
    kSeed = 1,
    kPrivateKey = 2,
    INPUT_NOT_SET = 0,
  };

  static inline const Keypair* internal_default_instance() {
    return reinterpret_cast<const Keypair*>(
               &_Keypair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Keypair& a, Keypair& b) {
    a.Swap(&b);
  }
  inline void Swap(Keypair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Keypair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Keypair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Keypair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Keypair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Keypair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Keypair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.Keypair";
  }
  protected:
  explicit Keypair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
  };
  // bytes seed = 1;
  bool has_seed() const;
  private:
  bool _internal_has_seed() const;
  public:
  void clear_seed();
  const std::string& seed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seed();
  PROTOBUF_NODISCARD std::string* release_seed();
  void set_allocated_seed(std::string* seed);
  private:
  const std::string& _internal_seed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seed(const std::string& value);
  std::string* _internal_mutable_seed();
  public:

  // bytes private_key = 2;
  bool has_private_key() const;
  private:
  bool _internal_has_private_key() const;
  public:
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  void clear_input();
  InputCase input_case() const;
  // @@protoc_insertion_point(class_scope:basic.Keypair)
 private:
  class _Internal;
  void set_has_seed();
  void set_has_private_key();

  inline bool has_input() const;
  inline void clear_has_input();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InputUnion {
    constexpr InputUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seed_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  } input_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// -------------------------------------------------------------------

class ProgramId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:basic.ProgramId) */ {
 public:
  inline ProgramId() : ProgramId(nullptr) {}
  ~ProgramId() override;
  explicit constexpr ProgramId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProgramId(const ProgramId& from);
  ProgramId(ProgramId&& from) noexcept
    : ProgramId() {
    *this = ::std::move(from);
  }

  inline ProgramId& operator=(const ProgramId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProgramId& operator=(ProgramId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProgramId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProgramId* internal_default_instance() {
    return reinterpret_cast<const ProgramId*>(
               &_ProgramId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProgramId& a, ProgramId& b) {
    a.Swap(&b);
  }
  inline void Swap(ProgramId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProgramId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProgramId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProgramId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProgramId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProgramId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProgramId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "basic.ProgramId";
  }
  protected:
  explicit ProgramId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .basic.Pubkey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::basic::Pubkey& id() const;
  PROTOBUF_NODISCARD ::basic::Pubkey* release_id();
  ::basic::Pubkey* mutable_id();
  void set_allocated_id(::basic::Pubkey* id);
  private:
  const ::basic::Pubkey& _internal_id() const;
  ::basic::Pubkey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::basic::Pubkey* id);
  ::basic::Pubkey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:basic.ProgramId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::basic::Pubkey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fbasic_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccountInfo

// uint64 slot = 1;
inline void AccountInfo::clear_slot() {
  slot_ = uint64_t{0u};
}
inline uint64_t AccountInfo::_internal_slot() const {
  return slot_;
}
inline uint64_t AccountInfo::slot() const {
  // @@protoc_insertion_point(field_get:basic.AccountInfo.slot)
  return _internal_slot();
}
inline void AccountInfo::_internal_set_slot(uint64_t value) {
  
  slot_ = value;
}
inline void AccountInfo::set_slot(uint64_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:basic.AccountInfo.slot)
}

// bytes value = 2;
inline void AccountInfo::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& AccountInfo::value() const {
  // @@protoc_insertion_point(field_get:basic.AccountInfo.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:basic.AccountInfo.value)
}
inline std::string* AccountInfo::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:basic.AccountInfo.value)
  return _s;
}
inline const std::string& AccountInfo::_internal_value() const {
  return value_.Get();
}
inline void AccountInfo::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountInfo::release_value() {
  // @@protoc_insertion_point(field_release:basic.AccountInfo.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountInfo::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:basic.AccountInfo.value)
}

// -------------------------------------------------------------------

// SignedTx

// bytes tx = 1;
inline void SignedTx::clear_tx() {
  tx_.ClearToEmpty();
}
inline const std::string& SignedTx::tx() const {
  // @@protoc_insertion_point(field_get:basic.SignedTx.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedTx::set_tx(ArgT0&& arg0, ArgT... args) {
 
 tx_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:basic.SignedTx.tx)
}
inline std::string* SignedTx::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:basic.SignedTx.tx)
  return _s;
}
inline const std::string& SignedTx::_internal_tx() const {
  return tx_.Get();
}
inline void SignedTx::_internal_set_tx(const std::string& value) {
  
  tx_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignedTx::_internal_mutable_tx() {
  
  return tx_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignedTx::release_tx() {
  // @@protoc_insertion_point(field_release:basic.SignedTx.tx)
  return tx_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignedTx::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  tx_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:basic.SignedTx.tx)
}

// -------------------------------------------------------------------

// TxStatusWithSlot

// .basic.TxStatus status = 1;
inline void TxStatusWithSlot::clear_status() {
  status_ = 0;
}
inline ::basic::TxStatus TxStatusWithSlot::_internal_status() const {
  return static_cast< ::basic::TxStatus >(status_);
}
inline ::basic::TxStatus TxStatusWithSlot::status() const {
  // @@protoc_insertion_point(field_get:basic.TxStatusWithSlot.status)
  return _internal_status();
}
inline void TxStatusWithSlot::_internal_set_status(::basic::TxStatus value) {
  
  status_ = value;
}
inline void TxStatusWithSlot::set_status(::basic::TxStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:basic.TxStatusWithSlot.status)
}

// uint64 slot = 2;
inline void TxStatusWithSlot::clear_slot() {
  slot_ = uint64_t{0u};
}
inline uint64_t TxStatusWithSlot::_internal_slot() const {
  return slot_;
}
inline uint64_t TxStatusWithSlot::slot() const {
  // @@protoc_insertion_point(field_get:basic.TxStatusWithSlot.slot)
  return _internal_slot();
}
inline void TxStatusWithSlot::_internal_set_slot(uint64_t value) {
  
  slot_ = value;
}
inline void TxStatusWithSlot::set_slot(uint64_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:basic.TxStatusWithSlot.slot)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Pubkey

// bytes data = 1;
inline void Pubkey::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Pubkey::data() const {
  // @@protoc_insertion_point(field_get:basic.Pubkey.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pubkey::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:basic.Pubkey.data)
}
inline std::string* Pubkey::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:basic.Pubkey.data)
  return _s;
}
inline const std::string& Pubkey::_internal_data() const {
  return data_.Get();
}
inline void Pubkey::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Pubkey::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Pubkey::release_data() {
  // @@protoc_insertion_point(field_release:basic.Pubkey.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Pubkey::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:basic.Pubkey.data)
}

// -------------------------------------------------------------------

// Keypair

// bytes seed = 1;
inline bool Keypair::_internal_has_seed() const {
  return input_case() == kSeed;
}
inline bool Keypair::has_seed() const {
  return _internal_has_seed();
}
inline void Keypair::set_has_seed() {
  _oneof_case_[0] = kSeed;
}
inline void Keypair::clear_seed() {
  if (_internal_has_seed()) {
    input_.seed_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_input();
  }
}
inline const std::string& Keypair::seed() const {
  // @@protoc_insertion_point(field_get:basic.Keypair.seed)
  return _internal_seed();
}
template <typename ArgT0, typename... ArgT>
inline void Keypair::set_seed(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_seed()) {
    clear_input();
    set_has_seed();
    input_.seed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_.seed_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:basic.Keypair.seed)
}
inline std::string* Keypair::mutable_seed() {
  std::string* _s = _internal_mutable_seed();
  // @@protoc_insertion_point(field_mutable:basic.Keypair.seed)
  return _s;
}
inline const std::string& Keypair::_internal_seed() const {
  if (_internal_has_seed()) {
    return input_.seed_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Keypair::_internal_set_seed(const std::string& value) {
  if (!_internal_has_seed()) {
    clear_input();
    set_has_seed();
    input_.seed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_.seed_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Keypair::_internal_mutable_seed() {
  if (!_internal_has_seed()) {
    clear_input();
    set_has_seed();
    input_.seed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return input_.seed_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Keypair::release_seed() {
  // @@protoc_insertion_point(field_release:basic.Keypair.seed)
  if (_internal_has_seed()) {
    clear_has_input();
    return input_.seed_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Keypair::set_allocated_seed(std::string* seed) {
  if (has_input()) {
    clear_input();
  }
  if (seed != nullptr) {
    set_has_seed();
    input_.seed_.UnsafeSetDefault(seed);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(seed);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:basic.Keypair.seed)
}

// bytes private_key = 2;
inline bool Keypair::_internal_has_private_key() const {
  return input_case() == kPrivateKey;
}
inline bool Keypair::has_private_key() const {
  return _internal_has_private_key();
}
inline void Keypair::set_has_private_key() {
  _oneof_case_[0] = kPrivateKey;
}
inline void Keypair::clear_private_key() {
  if (_internal_has_private_key()) {
    input_.private_key_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_input();
  }
}
inline const std::string& Keypair::private_key() const {
  // @@protoc_insertion_point(field_get:basic.Keypair.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline void Keypair::set_private_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_private_key()) {
    clear_input();
    set_has_private_key();
    input_.private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_.private_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:basic.Keypair.private_key)
}
inline std::string* Keypair::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:basic.Keypair.private_key)
  return _s;
}
inline const std::string& Keypair::_internal_private_key() const {
  if (_internal_has_private_key()) {
    return input_.private_key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Keypair::_internal_set_private_key(const std::string& value) {
  if (!_internal_has_private_key()) {
    clear_input();
    set_has_private_key();
    input_.private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_.private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Keypair::_internal_mutable_private_key() {
  if (!_internal_has_private_key()) {
    clear_input();
    set_has_private_key();
    input_.private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return input_.private_key_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Keypair::release_private_key() {
  // @@protoc_insertion_point(field_release:basic.Keypair.private_key)
  if (_internal_has_private_key()) {
    clear_has_input();
    return input_.private_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Keypair::set_allocated_private_key(std::string* private_key) {
  if (has_input()) {
    clear_input();
  }
  if (private_key != nullptr) {
    set_has_private_key();
    input_.private_key_.UnsafeSetDefault(private_key);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(private_key);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:basic.Keypair.private_key)
}

inline bool Keypair::has_input() const {
  return input_case() != INPUT_NOT_SET;
}
inline void Keypair::clear_has_input() {
  _oneof_case_[0] = INPUT_NOT_SET;
}
inline Keypair::InputCase Keypair::input_case() const {
  return Keypair::InputCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProgramId

// .basic.Pubkey id = 1;
inline bool ProgramId::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ProgramId::has_id() const {
  return _internal_has_id();
}
inline void ProgramId::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::basic::Pubkey& ProgramId::_internal_id() const {
  const ::basic::Pubkey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::basic::Pubkey&>(
      ::basic::_Pubkey_default_instance_);
}
inline const ::basic::Pubkey& ProgramId::id() const {
  // @@protoc_insertion_point(field_get:basic.ProgramId.id)
  return _internal_id();
}
inline void ProgramId::unsafe_arena_set_allocated_id(
    ::basic::Pubkey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:basic.ProgramId.id)
}
inline ::basic::Pubkey* ProgramId::release_id() {
  
  ::basic::Pubkey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::basic::Pubkey* ProgramId::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:basic.ProgramId.id)
  
  ::basic::Pubkey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::basic::Pubkey* ProgramId::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::basic::Pubkey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::basic::Pubkey* ProgramId::mutable_id() {
  ::basic::Pubkey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:basic.ProgramId.id)
  return _msg;
}
inline void ProgramId::set_allocated_id(::basic::Pubkey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::basic::Pubkey>::GetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:basic.ProgramId.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace basic

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::basic::TxStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::basic::TxStatus>() {
  return ::basic::TxStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fbasic_2eproto
